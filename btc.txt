import sys
import json
import asyncio
import os
import logging
from logging.handlers import RotatingFileHandler
import traceback
from typing import Optional, Tuple, Dict, List
import ccxt.async_support as ccxt
import aiohttp
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import io
import time
from collections import defaultdict
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import BadRequest, Forbidden
from telegram import InputMediaPhoto
from tenacity import retry, stop_after_attempt, wait_fixed
import portalocker
import ta
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Error logger
error_handler = RotatingFileHandler('errors.log', mode='a', maxBytes=10*1024*1024, backupCount=5)
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(error_handler)

# Event logger
event_handler = RotatingFileHandler('events.log', mode='a', maxBytes=10*1024*1024, backupCount=5)
event_handler.setLevel(logging.INFO)
event_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
event_logger = logging.getLogger('events')
event_logger.addHandler(event_handler)
event_logger.setLevel(logging.INFO)
try:
    with open('config.json', 'r') as f:
        CONFIG = json.load(f)
except FileNotFoundError:
    print("FATAL ERROR: config.json not found. Please ensure the configuration file exists.")
    sys.exit(1)
except json.JSONDecodeError:
    print("FATAL ERROR: config.json is not valid JSON. Please check the file content.")
    sys.exit(1)

# Configuration

class RateLimiter:
    def __init__(self):
        self.user_requests = defaultdict(list)
        self.banned_users = {}
        self.MAX_REQUESTS = 30
        self.WARNING_THRESHOLD = 20
        self.TIME_WINDOW = 60
        self.BAN_DURATION = 3600

    def check_rate_limit(self, user_id: str) -> Tuple[bool, Optional[str]]:
        current_time = time.time()

        # تنظيف الطلبات القديمة
        self.user_requests[user_id] = [
            t for t in self.user_requests[user_id]
            if current_time - t < self.TIME_WINDOW
        ]
        self.user_requests[user_id].append(current_time)

        # فحص المستخدمين المحظورين
        if user_id in self.banned_users:
            ban_time = self.banned_users[user_id]
            if current_time - ban_time < self.BAN_DURATION:
                remaining = int(self.BAN_DURATION - (current_time - ban_time))
                return False, f"🚫 **تم حظرك** لمدة {remaining // 60} دقيقة بسبب الاستخدام المفرط.\n📌 حاول مرة أخرى بعد انتهاء الحظر."
            else:
                del self.banned_users[user_id]
                self.user_requests[user_id].clear()

        # فحص حد الطلبات
        if len(self.user_requests[user_id]) > self.MAX_REQUESTS:
            self.banned_users[user_id] = current_time
            return False, f"🚫 **تم حظرك** لمدة ساعة بسبب الاستخدام المفرط.\n📌 حاول مرة أخرى بعد انتهاء الحظر."
        elif len(self.user_requests[user_id]) > self.WARNING_THRESHOLD:
            return True, f"⚠️ **تحذير**: أنت تستخدم البوت بسرعة كبيرة!\n📌 لو استمر الاستخدام المفرط، سيتم حظرك لمدة ساعة."

        return True, None

class TelegramErrorHandler(logging.Handler):
    def __init__(self, bot_app_provider, error_group_id):
        super().__init__()
        self.bot_app_provider = bot_app_provider  # This will be a function/lambda to get the bot app
        self.error_group_id = error_group_id
        self.pending_messages = []

    async def send_message_async(self, text_message):
        application = self.bot_app_provider()
        if application and self.error_group_id:
            try:
                # Clean message from markdown characters that might break the formatting
                clean_message = text_message.replace('`', '').replace('*', '').replace('_', '')
                # Split message if too long
                max_length = 4000  # Telegram message length limit
                if len(clean_message) > max_length:
                    parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]
                    for part in parts:
                        await application.bot.send_message(
                            chat_id=self.error_group_id,
                            text=f"⚠️ **Error Log**:\n```\n{part}\n```",
                            parse_mode='Markdown'
                        )
                else:
                    await application.bot.send_message(
                        chat_id=self.error_group_id,
                        text=f"⚠️ **Error Log**:\n```\n{clean_message}\n```",
                        parse_mode='Markdown'
                    )
            except Exception as e:
                # Use the main logger to log an error if sending to Telegram fails,
                # to avoid recursion if this handler is itself causing an error.
                # Get the root logger to avoid self-referential logging if 'logger' is the one this handler is attached to.
                logging.getLogger().error(f"TelegramErrorHandler failed to send message: {e}", exc_info=True)

    def process_pending_messages(self):
        application = self.bot_app_provider()
        if application:
            while self.pending_messages:
                message = self.pending_messages.pop(0)
                asyncio.create_task(self.send_message_async(message))

    def emit(self, record):
        if not self.error_group_id: # Do nothing if error_group_id is not set
            return

        log_message = self.format(record)
        application = self.bot_app_provider()

        if application and application.bot:
            self.process_pending_messages() # Process any backlog
            asyncio.create_task(self.send_message_async(log_message))
        else:
            self.pending_messages.append(log_message)

class TelegramEventLogHandler(logging.Handler):
    def __init__(self, bot_app_provider, event_group_id):
        super().__init__()
        self.bot_app_provider = bot_app_provider
        self.event_group_id = event_group_id
        self.pending_messages = []

    async def send_message_async(self, text_message):
        application = self.bot_app_provider()
        if application and self.event_group_id:
            try:
                # Clean message from markdown characters that might break the formatting
                # For event logs, we might want to keep some markdown if used deliberately.
                # However, for consistency with error handler and safety:
                clean_message = text_message.replace('`', '').replace('*', '').replace('_', '')

                # Split message if too long
                max_length = 4000  # Telegram message length limit
                # Add a prefix to distinguish event logs
                prefix = "🔔 **Event Log**:\n"

                if len(prefix + clean_message) > max_length:
                    # If the message itself is too long, truncate or split
                    # For simplicity, let's send it as is and rely on Telegram's handling or truncate
                    # A more robust way would be to split like in TelegramErrorHandler
                    parts = [clean_message[i:i+max_length-len(prefix)] for i in range(0, len(clean_message), max_length-len(prefix))]
                    for part in parts:
                            await application.bot.send_message(
                            chat_id=self.event_group_id,
                            text=f"{prefix}{part}",
                            parse_mode='Markdown' # Or None if we don't want markdown for events
                        )
                else:
                        await application.bot.send_message(
                        chat_id=self.event_group_id,
                        text=f"{prefix}{clean_message}",
                        parse_mode='Markdown' # Or None
                    )
            except Exception as e:
                logging.getLogger().error(f"TelegramEventLogHandler failed to send message: {e}", exc_info=True)

    def process_pending_messages(self):
        application = self.bot_app_provider()
        if application:
            while self.pending_messages:
                message = self.pending_messages.pop(0)
                asyncio.create_task(self.send_message_async(message))

    def emit(self, record):
        if not self.event_group_id: # Do nothing if event_group_id is not set
            return

        log_message = self.format(record) # Get the formatted message
        # The default event logger format is '%(asctime)s - %(message)s'
        # We might want to send only record.getMessage() if the formatter is too verbose for Telegram
        # For now, let's use the formatted message.

        application = self.bot_app_provider()

        if application and application.bot:
            self.process_pending_messages()
            asyncio.create_task(self.send_message_async(log_message))
        else:
            self.pending_messages.append(log_message)

class TradingBot:
    def __init__(self, config: Dict[str, str]):
        """تهيئة البوت"""
        self.config = config
        self.exchange = None
        self.application = None
        self.cached_data = {}
        self.waiting_for_group_id = False
        self.command_usage = defaultdict(int)
        self.rate_limiter = RateLimiter()
        self.last_cache_cleanup = time.time()
        self.telegram_error_handler = None
        self.telegram_event_log_handler = None
        self.user_chart_themes = {}

        # إضافة المتغيرات المفقودة
        self.admin_settings = {
            'private_enabled': True,
            'active_group_id': self.config.get('default_group_id', ''),
            'active_group_name': 'غير محددة'
        }

        # تعريف المؤشرات الفنية المطلوبة
        self.features = [
            'RSI_14', 'RSI_7', 'RSI_21', 'MACD', 'MACD_signal', 'Bollinger_width',
            'ATR_14', 'ATR_7', 'Stochastic', 'Volume_MA_20', 'Volume_MA_50',
            'MA_5', 'MA_10', 'MA_20', 'MA_50', 'MA_200', 'EMA_12', 'EMA_26', 'EMA_50'
        ]

        # تعريف مدد الإطارات الزمنية
        self.timeframe_durations = {
            '1m': timedelta(minutes=1),
            '5m': timedelta(minutes=5),
            '15m': timedelta(minutes=15),
            '30m': timedelta(minutes=30),
            '1h': timedelta(hours=1),
            '4h': timedelta(hours=4),
            '1d': timedelta(days=1),
            '1w': timedelta(weeks=1)
        }

        self.health_check = {
            'last_check': time.time(),
            'status': 'healthy',
            'errors': []
        }

        self.fallback_config = {
            'use_cache': True,
            'retry_attempts': 3,
            'timeout': 30,
            'max_errors': 5
        }

    async def health_check_system(self):
        """فحص صحة البوت"""
        try:
            current_time = time.time()
            if current_time - self.health_check['last_check'] < 300:  # كل 5 دقائق
                return self.health_check['status']

            # فحص الاتصال بالمنصة
            if not self.exchange:
                if not await self.init_exchange():
                    self.health_check['status'] = 'degraded'
                    self.health_check['errors'].append('فشل الاتصال بالمنصة')
                    return 'degraded'

            # فحص الاتصال بتيليجرام
            if self.application:
                try:
                    await self.application.bot.get_me()
                except Exception as e:
                    self.health_check['status'] = 'degraded'
                    self.health_check['errors'].append(f'فشل الاتصال بتيليجرام: {e}')
                    return 'degraded'

            # تحديث الحالة
            self.health_check['last_check'] = current_time
            self.health_check['status'] = 'healthy'
            self.health_check['errors'] = []
            return 'healthy'

        except Exception as e:
            logger.error(f"خطأ في فحص الصحة: {e}")
            self.health_check['status'] = 'degraded'
            self.health_check['errors'].append(str(e))
            return 'degraded'

    async def init_exchange(self) -> bool:
        """تهيئة المنصة مع آلية استعادة"""
        try:
            if self.exchange:
                try:
                    # اختبار الاتصال الحالي
                    await self.exchange.fetch_status()
                    return True
                except:
                    # إذا فشل الاختبار، أعد التهيئة
                    self.exchange = None

            # محاولة تهيئة المنصة
            self.exchange = ccxt.mexc({
                'enableRateLimit': True,
                'timeout': self.fallback_config['timeout'] * 1000,
                'sandbox': False
            })

            # اختبار الاتصال
            await self.exchange.load_markets()
            logger.info("تم تهيئة المنصة بنجاح")
            return True

        except Exception as e:
            logger.error(f"فشل تهيئة المنصة: {e}")
            self.exchange = None
            return False

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1m', limit: int = 500) -> Optional[pd.DataFrame]:
        """جلب بيانات OHLCV مع آلية استعادة"""
        try:
            # فحص الصحة
            if await self.health_check_system() == 'degraded':
                logger.warning(f"حالة البوت متدهورة، استخدام البيانات المخزنة مؤقتاً لـ {symbol}")
                return self._get_cached_data(symbol, timeframe)

            if not self.exchange:
                if not await self.init_exchange():
                    return self._get_cached_data(symbol, timeframe)

            # جلب البيانات
            async with asyncio.timeout(self.fallback_config['timeout']):
                ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
                if not ohlcv:
                    return self._get_cached_data(symbol, timeframe)

            # معالجة البيانات
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

            # حفظ في الذاكرة المؤقتة
            self._cache_data(symbol, timeframe, df)
            return df

        except asyncio.TimeoutError:
            logger.warning(f"انتهت مهلة الاتصال في جلب بيانات {symbol}")
            return self._get_cached_data(symbol, timeframe)
        except Exception as e:
            logger.error(f"خطأ في جلب بيانات {symbol}: {e}")
            return self._get_cached_data(symbol, timeframe)

    def _get_cached_data(self, symbol: str, timeframe: str) -> Optional[pd.DataFrame]:
        """استرجاع البيانات المخزنة مؤقتاً"""
        cache_key = f"{symbol}:{timeframe}"
        if cache_key in self.cached_data:
            cached, timestamp = self.cached_data[cache_key]
            if (time.time() - timestamp) < 300:  # 5 دقائق
                return cached
        return None

    def _cache_data(self, symbol: str, timeframe: str, df: pd.DataFrame):
        """تخزين البيانات مؤقتاً"""
        cache_key = f"{symbol}:{timeframe}"
        self.cached_data[cache_key] = (df, time.time())

    def _parse_symbol(self, input_symbol: str) -> str:
        """تحليل رمز العملة مع معالجة الحالات المختلفة"""
        try:
            if not input_symbol or not isinstance(input_symbol, str):
                return self.config['default_symbol']

            # تنظيف الرمز
            symbol = input_symbol.strip().upper()

            if not symbol:
                return self.config['default_symbol']

            # إذا كان يحتوي على /
            if '/' in symbol:
                parts = symbol.split('/')
                if len(parts) == 2 and parts[0] and parts[1]:
                    return symbol
                else:
                    # إذا كان التنسيق غير صحيح
                    base = parts[0] if parts[0] else 'BTC'
                    return f"{base}/USDT"
            else:
                # إذا لم يحتوي على /، أضف USDT افتراضياً
                return f"{symbol}/USDT"

        except Exception as e:
            logger.error(f"خطأ في تحليل رمز العملة: {e}")
            return self.config['default_symbol']

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_current_price(self, symbol: str) -> Optional[Dict]:
        """جلب السعر الحالي للعملة"""
        try:
            if not symbol or not isinstance(symbol, str):
                logger.error(f"رمز عملة غير صالح: {symbol}")
                return None

            # تحليل الرمز للتأكد من صحته
            parsed_symbol = self._parse_symbol(symbol)

            # التحقق من صحة الرمز
            if len(parsed_symbol.split('/')) != 2:
                logger.error(f"تنسيق رمز العملة غير صالح: {symbol}")
                return None

            if not self.exchange:
                if not await self.init_exchange():
                    return None

            ticker = await self.exchange.fetch_ticker(parsed_symbol)
            if not ticker or 'last' not in ticker:
                logger.error(f"لم يتم العثور على بيانات السعر لـ {parsed_symbol}")
                return None

            return {
                'last': float(ticker['last']),
                'percentage': float(ticker.get('percentage', 0)),
                'high': float(ticker.get('high', 0)),
                'low': float(ticker.get('low', 0)),
                'volume': float(ticker.get('baseVolume', 0)),
                'symbol': parsed_symbol
            }

        except ccxt.NetworkError as e:
            logger.error(f"خطأ في الشبكة أثناء جلب السعر لـ {symbol}: {e}")
            return None
        except ccxt.ExchangeError as e:
            logger.error(f"خطأ في البورصة أثناء جلب السعر لـ {symbol}: {e}")
            return None
        except Exception as e:
            logger.error(f"خطأ غير متوقع أثناء جلب السعر لـ {symbol}: {e}")
            return None

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_dex_price(self, symbol: str) -> Optional[List[Dict]]:
        """جلب السعر من منصات DEX"""
        try:
            async with asyncio.timeout(10):
                # تحليل الرمز بشكل آمن
                if '/' in symbol:
                    base, quote = symbol.split('/', 1)  # استخدام maxsplit=1
                else:
                    # إذا لم يحتوي على /, افترض USDT كعملة مقابلة
                    base = symbol
                    quote = 'USDT'

                url = f"https://api.dexscreener.com/latest/dex/search?q={base}"

                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=10) as response:
                        response.raise_for_status()
                        data = await response.json()

                pairs = []
                for pair in data.get('pairs', []):
                    if pair.get('quoteToken', {}).get('symbol', '').upper() == quote.upper():
                        pairs.append({
                            'price': float(pair.get('priceUsd', 0)),
                            'dex': pair.get('dexId', 'Unknown'),
                            'liquidity': float(pair.get('liquidity', {}).get('usd', 0)),
                            'volume_24h': float(pair.get('volume', {}).get('h24', 0)), # Renamed
                            'change_24h': float(pair.get('priceChange', {}).get('h24', 0)),
                            'change_1h': float(pair.get('priceChange', {}).get('h1', 0)),   # New
                            'market_cap': float(pair.get('fdv', 0)) # New, from 'fdv'
                        })

                # Sort by liquidity to get the most relevant pair first potentially
                if pairs:
                    pairs.sort(key=lambda x: x['liquidity'], reverse=True)
                return pairs if pairs else None

        except Exception as e:
            error_msg = f"خطأ في جلب سعر {symbol} من DEX: {e}"
            logger.error(error_msg)
            # Removed: asyncio.create_task(self.send_to_error_group(error_msg))
            # logger.error should now trigger TelegramErrorHandler
            return None

    async def send_to_log_group(self, message: str):
        """إرسال رسالة إلى جروب السجلات"""
        try:
            if self.application and self.config.get('log_group_id'):
                await self.application.bot.send_message(
                    chat_id=self.config['log_group_id'],
                    text=message,
                    parse_mode='Markdown'
                )
        except (BadRequest, Forbidden) as e:
            logger.error(f"خطأ في إرسال السجل إلى جروب السجلات: {e}")

    async def send_to_error_group(self, message: str):
        """إرسال رسالة خطأ إلى جروب الأخطاء"""
        try:
            if not self.application or not self.config.get('error_group_id'):
                return

            # تنظيف الرسالة من الأحرف الخاصة
            clean_message = message.replace('`', '').replace('*', '').replace('_', '')

            # تقسيم الرسالة إذا كانت طويلة جداً
            max_length = 4000
            if len(clean_message) > max_length:
                parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]
                for part in parts:
                    await self.application.bot.send_message(
                        chat_id=self.config['error_group_id'],
                        text=f"⚠️ **خطأ في النظام**\n```\n{part}\n```",
                        parse_mode='Markdown'
                    )
            else:
                await self.application.bot.send_message(
                    chat_id=self.config['error_group_id'],
                    text=f"⚠️ **خطأ في النظام**\n```\n{clean_message}\n```",
                    parse_mode='Markdown'
                )
        except Exception as e:
            logger.error(f"خطأ في إرسال الخطأ إلى جروب الأخطاء: {e}")

    # The send_to_error_group method is now removed.
    # Its functionality is replaced by the TelegramErrorHandler.

    async def check_access(self, update: Update) -> bool:
        """فحص صلاحية الوصول للمستخدم"""
        try:
            user_id = str(update.effective_user.id)
            chat_id = str(update.effective_chat.id)
            is_private = update.effective_chat.type == 'private'
            is_admin = user_id == self.config['admin_id']

            if is_admin:
                return True

            # فحص حد الطلبات
            allowed, message = self.rate_limiter.check_rate_limit(user_id)
            if not allowed:
                await update.message.reply_text(message, parse_mode='Markdown')
                if "تم حظرك" in message:
                    # This was a direct call to send_to_error_group.
                    # Now, we should log an error, and the handler will pick it up.
                    logger.error(
                        f"User {update.effective_user.first_name} (ID: {user_id}) banned for rate limiting."
                    )
                return False

            # فحص الدردشة الخاصة
            if is_private and not self.admin_settings['private_enabled']:
                await update.message.reply_text(
                    "⚠️ الإدارة قفلت استخدام البوت في الدردشة الخاصة حاليًا.\n📌 حاول لاحقًا أو تواصل مع الأدمن.",
                    parse_mode='Markdown'
                )
                return False

            # فحص المجموعة النشطة
            if not is_private and self.admin_settings.get('active_group_id') and chat_id != self.admin_settings['active_group_id']:
                return False

            # إرسال رسالة تحذير إذا وُجدت
            if message:
                await update.message.reply_text(message, parse_mode='Markdown')

            return True
        except Exception as e:
            logger.error(f"خطأ في فحص الصلاحية: {e}")
            return False

    async def admin_panel(self, update: Update, context):
        """لوحة تحكم الأدمن"""
        try:
            if str(update.effective_user.id) != self.config['admin_id']:
                await update.message.reply_text("⚠️ هذا الأمر متاح للأدمن فقط!", parse_mode='Markdown')
                return

            keyboard = [
                [
                    InlineKeyboardButton(
                        f"{'إيقاف' if self.admin_settings['private_enabled'] else 'تفعيل'} الدردشة الخاصة",
                        callback_data='admin_toggle_private'
                    )
                ],
                [
                    InlineKeyboardButton("تعيين مجموعة", callback_data='admin_set_group')
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            status_msg = (
                f"🛠️ **لوحة تحكم الأدمن** 🛠️\n\n"
                f"📱 الدردشة الخاصة: {'مفعلة' if self.admin_settings['private_enabled'] else 'مقفلة'}\n"
                f"👥 المجموعة النشطة: {self.admin_settings['active_group_name']}\n"
                f"⚡ حالة البوت: {await self.health_check_system()}\n\n"
                f"اختر إعدادًا لتخصيصه:"
            )

            await update.message.reply_text(
                status_msg,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"خطأ في لوحة تحكم الأدمن: {e}")
            await update.message.reply_text("⚠️ حدث خطأ في تحميل لوحة التحكم.")

    async def handle_admin_callback(self, update: Update, context):
        """معالجة أزرار لوحة تحكم الأدمن"""
        try:
            query = update.callback_query
            await query.answer()

            if str(query.from_user.id) != self.config['admin_id']:
                await query.message.reply_text("⚠️ هذا الأمر متاح للأدمن فقط!", parse_mode='Markdown')
                return

            data = query.data

            if data == 'admin_toggle_private':
                self.admin_settings['private_enabled'] = not self.admin_settings['private_enabled']
                status = "مفعلة" if self.admin_settings['private_enabled'] else "مقفلة"
                await query.message.edit_text(
                    f"✅ تم {'تفعيل' if self.admin_settings['private_enabled'] else 'إيقاف'} الدردشة الخاصة.\nالحالة الحالية: {status}",
                    parse_mode='Markdown'
                )
                await self.send_to_log_group(f"تم {'تفعيل' if self.admin_settings['private_enabled'] else 'إيقاف'} الدردشة الخاصة من قبل الأدمن.")

            elif data == 'admin_set_group':
                self.waiting_for_group_id = True
                await query.message.edit_text(
                    "📌 من فضلك، أرسل ID المجموعة (مثال: -1001234567890) لتفعيل البوت فيها.",
                    parse_mode='Markdown'
                )

        except Exception as e:
            logger.error(f"خطأ في معالجة أزرار الأدمن: {e}")

    async def handle_group_id(self, update: Update, context):
        """معالجة تعيين ID المجموعة"""
        try:
            if not self.waiting_for_group_id or str(update.effective_user.id) != self.config['admin_id']:
                return

            group_id = update.message.text.strip()
            chat = await context.bot.get_chat(group_id)

            self.admin_settings['active_group_id'] = group_id
            self.admin_settings['active_group_name'] = chat.title
            self.waiting_for_group_id = False

            await update.message.reply_text(
                f"✅ تم تعيين المجموعة **{chat.title}** (ID: {group_id}) بنجاح!",
                parse_mode='Markdown'
            )

            await context.bot.send_message(
                chat_id=group_id,
                text=(
                    f"🎉 **تم تفعيل البوت في مجموعة {chat.title}** بواسطة {update.effective_user.first_name}! 🚀\n"
                    "📋 استخدم `/help` أو 'مساعدة' لعرض الأوامر المتاحة.\n"
                    "💡 جاهز لخدمتكم في تحليل الأسعار والتداول!"
                ),
                parse_mode='Markdown'
            )

            await self.send_to_log_group(f"تم تفعيل البوت في المجموعة {chat.title} (ID: {group_id}) من قبل الأدمن.")

        except Exception as e:
            await update.message.reply_text(
                f"⚠️ خطأ في تعيين المجموعة. تأكد من إدخال ID صحيح وأن البوت عضو في المجموعة.",
                parse_mode='Markdown'
            )
            logger.error(f"خطأ في تعيين المجموعة {group_id}: {e}") # Changed from direct send_to_error_group

    def _format_large_number(self, num: float) -> str:
        if num is None:
            return "N/A"
        if abs(num) >= 1_000_000_000:
            return f"${num / 1_000_000_000:.2f}B"
        elif abs(num) >= 1_000_000:
            return f"${num / 1_000_000:.2f}M"
        elif abs(num) >= 1_000:
            return f"${num / 1_000:.2f}K"
        return f"${num:,.2f}" # Added comma for numbers < 1K but > 0

    def _format_percentage(self, change: Optional[float]) -> str:
        if change is None:
            return "N/A"
        emoji = "📈" if change >= 0 else "📉"
        return f"{emoji} {change:+.2f}%"

    async def _get_price_and_reply(self, update: Update, context, requested_arg: Optional[str]):
        """جلب السعر والرد على المستخدم مع معلومات مفصلة"""
        try:
            if not requested_arg:
                await update.message.reply_text(
                    "⚠️ من فضلك، أدخل رمز العملة (مثال: /price BTC أو سعر BTC).",
                    parse_mode='Markdown'
                )
                return

            parsed_symbol_for_cex = self._parse_symbol(requested_arg) # Ensures SYMBOL/USDT format for CEX
            base_currency = requested_arg.split('/')[0].upper() # For DEX search and display name

            reply_message_lines = []
            found_on_cex = False

            # CEX Data Fetching (MEXC)
            if self.exchange or await self.init_exchange():
                try:
                    ticker_data = await self.fetch_current_price(parsed_symbol_for_cex)
                    if ticker_data:
                        found_on_cex = True
                        price = ticker_data['last']
                        display_symbol_cex = ticker_data['symbol']

                        reply_message_lines.append(f"💎 **{base_currency} ({display_symbol_cex} - MEXC)**")
                        reply_message_lines.append(f"💰 **Price: `{self._format_price(price)}`**")

                        change_24h_cex = ticker_data.get('percentage')
                        reply_message_lines.append(f"📊 24h Change: {self._format_percentage(change_24h_cex)}")

                        # OHLCV for 1h, 7d, 30d changes
                        # 1h change
                        ohlcv_1h_data = await self.fetch_ohlcv(display_symbol_cex, '1h', limit=1) # Fetch the last completed 1h candle
                        if ohlcv_1h_data and len(ohlcv_1h_data) == 1:
                            price_1h_ago = ohlcv_1h_data[0]['close']
                            change_1h = ((price - price_1h_ago) / price_1h_ago) * 100 if price_1h_ago else None
                            reply_message_lines.append(f"⏳ 1h Change: {self._format_percentage(change_1h)}")
                        else:
                            reply_message_lines.append("⏳ 1h Change: N/A")

                        # 7d change
                        ohlcv_7d_data = await self.fetch_ohlcv(display_symbol_cex, '1d', limit=7) # Fetch last 7 completed daily candles
                        if ohlcv_7d_data and len(ohlcv_7d_data) == 7:
                            price_7d_ago = ohlcv_7d_data[0]['close'] # Oldest candle is 7 days ago
                            change_7d = ((price - price_7d_ago) / price_7d_ago) * 100 if price_7d_ago else None
                            reply_message_lines.append(f"📅 7d Change: {self._format_percentage(change_7d)}")
                        else:
                            reply_message_lines.append("📅 7d Change: N/A")

                        # 30d change
                        ohlcv_30d_data = await self.fetch_ohlcv(display_symbol_cex, '1d', limit=30) # Fetch last 30 completed daily candles
                        if ohlcv_30d_data and len(ohlcv_30d_data) == 30:
                            price_30d_ago = ohlcv_30d_data[0]['close'] # Oldest candle is 30 days ago
                            change_30d = ((price - price_30d_ago) / price_30d_ago) * 100 if price_30d_ago else None
                            reply_message_lines.append(f"🗓️ 30d Change: {self._format_percentage(change_30d)}")
                        else:
                            reply_message_lines.append("🗓️ 30d Change: N/A")

                        vol_24h_base = ticker_data.get('volume', 0.0)
                        vol_24h_quote = vol_24h_base * price # Approximate quote volume
                        reply_message_lines.append(f"📈 24h Volume: {self._format_large_number(vol_24h_quote)}")
                        reply_message_lines.append(f"🔼 High 24h: `{self._format_price(ticker_data.get('high'))}`")
                        reply_message_lines.append(f"🔽 Low 24h: `{self._format_price(ticker_data.get('low'))}`")
                        reply_message_lines.append(f"🏦 Market Cap: N/A (CEX)") # Market Cap not typically available from CEX ticker
                        reply_message_lines.append(f"🕒 {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}")
                except Exception as e:
                    logger.error(f"Error fetching or processing CEX data for {parsed_symbol_for_cex}: {e}", exc_info=True)
                    if not found_on_cex: # Only add error if this was the primary attempt
                        reply_message_lines.append(f"ℹ️ CEX data for {parsed_symbol_for_cex} incomplete or unavailable.")

            # DEX Data Fetching (DexScreener) - Try if not found on CEX or as supplemental
            # Use base_currency for DEX search as it's more general
            dex_pairs = await self.fetch_dex_price(base_currency)
            if dex_pairs:
                best_dex_pair = dex_pairs[0] # Already sorted by liquidity in fetch_dex_price

                if found_on_cex:
                    reply_message_lines.append("\n--- Also found on DEX ---")

                reply_message_lines.append(f"🦎 **{base_currency} (DEX - {best_dex_pair['dex']})**")
                reply_message_lines.append(f"💰 **Price: `{self._format_price(best_dex_pair['price'])}`**")
                reply_message_lines.append(f"⏳ 1h Change: {self._format_percentage(best_dex_pair.get('change_1h'))}")
                reply_message_lines.append(f"📊 24h Change: {self._format_percentage(best_dex_pair.get('change_24h'))}")
                reply_message_lines.append(f"📈 24h Volume: {self._format_large_number(best_dex_pair.get('volume_24h'))}")
                reply_message_lines.append(f"💧 Liquidity: {self._format_large_number(best_dex_pair.get('liquidity'))}")
                reply_message_lines.append(f"🏦 Market Cap: {self._format_large_number(best_dex_pair.get('market_cap'))}")
                reply_message_lines.append(f"🕒 {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}")
            elif not found_on_cex:
                reply_message_lines.append(f"⚠️ تعذر جلب السعر لـ {requested_arg} من المصادر المتاحة.")

            if reply_message_lines:
                await update.message.reply_text("\n".join(reply_message_lines), parse_mode='Markdown')
            # If still no lines (e.g. CEX init failed and DEX failed), the initial error message is sent by price command

        except Exception as e:
            error_msg = f"خطأ شامل في _get_price_and_reply لـ {requested_arg}: {e}"
            logger.error(error_msg, exc_info=True)
            await update.message.reply_text(
                "⚠️ حدث خطأ كبير أثناء معالجة طلبك. تم إبلاغ الإدارة.",
                parse_mode='Markdown'
            )

    # أوامر البوت
    async def start(self, update: Update, context):
        """أمر البدء"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['start'] += 1
            group_name = self.admin_settings.get('active_group_name', 'غير محددة')

            await update.message.reply_text(
                f"👋 **مرحبًا بك في بوت التداول!** 🚀\n"
                f"📈 أنا هنا لمساعدتك في تحليل الأسعار، توقعات السوق، وفرص التداول.\n"
                f"📍 البوت مفعل في المجموعة: **{group_name}**\n"
                f"📋 استخدم `/help` أو اكتب 'مساعدة' لعرض الأوامر المتاحة.\n"
                f"💡 جاهز لخدمتك!",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"خطأ في أمر البدء: {e}")
            await update.message.reply_text("⚠️ حدث خطأ. حاول مرة أخرى.")

    async def help(self, update: Update, context):
        """أمر المساعدة"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['help'] += 1

            await update.message.reply_text(
                """📋 **قائمة الأوامر المتاحة**:

👋 `/start` - بدء التفاعل مع البوت
💰 `/price <رمز>` - عرض السعر الحالي لزوج تداول (مثال: BTC/USDT)
🔍 `/search <رمز>` - البحث عن أزواج تداول (مثال: BTC)
📊 `/chart <رمز>` - عرض رسم بياني لزوج تداول
🛠️ `/admin` - لوحة تحكم الأدمن (للأدمن فقط)
✅ `/running` أو 'حالة' - التحقق من حالة البوت

💡 يمكنك كتابة الأوامر بالإنجليزية أو العربية (مثل 'مساعدة' بدل `/help`)
💡 يمكنك كتابة رمز العملة مباشرة (مثل BTC أو ETH) للحصول على السعر""",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"خطأ في أمر المساعدة: {e}")
            await update.message.reply_text("⚠️ حدث خطأ. حاول مرة أخرى.")

    async def price(self, update: Update, context):
        """أمر عرض السعر"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['price'] += 1

            # التحقق من المدخلات
            if not context.args:
                await update.message.reply_text(
                    "⚠️ من فضلك، أدخل رمز العملة (مثال: /price BTC أو /price BTC/USDT).",
                    parse_mode='Markdown'
                )
                return

            symbol_input = ' '.join(context.args)
            await self._get_price_and_reply(update, context, symbol_input)

        except Exception as e:
            error_msg = f"خطأ في أمر السعر: {e}"
            logger.error(error_msg) # TelegramErrorHandler will pick this up
            await update.message.reply_text(
                '⚠️ حدث خطأ أثناء معالجة طلبك. حاول مرة أخرى لاحقًا.',
                parse_mode='Markdown'
            )

    async def search(self, update: Update, context):
        """أمر البحث عن أزواج التداول في المنصات المركزية واللامركزية"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['search'] += 1

            if not context.args:
                await update.message.reply_text('⚠️ من فضلك، أدخل رمزًا للبحث (مثال: /search BTC)')
                return

            search_term = context.args[0].upper()
            response = f"🔍 **نتائج البحث عن {search_term}**:\n\n"
            found_results = False

            # CEX Search Logic
            cex_results = []
            if not self.exchange:
                if not await self.init_exchange():
                    logger.warning("فشل تهيئة المنصة للبحث في CEX. الاعتماد على DEX فقط.")

            if self.exchange: # Proceed if exchange is initialized
                try:
                    markets = await self.exchange.load_markets()
                    for market_symbol, market_data in markets.items():
                        if market_data.get('base', '').upper() == search_term:
                            cex_results.append(market_data['symbol'])

                    if cex_results:
                        cex_results.sort() # Sort for consistent order
                        response += "**منصات مركزية (CEX - MEXC):**\n"
                        for i, symbol in enumerate(cex_results[:10]): # Show up to 10 CEX results
                            response += f"{i+1}. `{symbol}`\n"
                        response += "\n"
                        found_results = True
                except Exception as e:
                    logger.error(f"خطأ أثناء البحث في أسواق CEX عن {search_term}: {e}")
                    # Do not send a message to user here, proceed to DEX search

            # DEX Search Logic
            dex_pairs = None
            try:
                dex_pairs = await self.fetch_dex_price(search_term) # fetch_dex_price uses search_term as base
                if dex_pairs:
                    response += "**منصات لامركزية (DEX):**\n"
                    for i, pair in enumerate(dex_pairs[:5]):  # Show up to 5 DEX results
                        response += f"{i+1}. `{pair['price']:.6f}` USD ({pair['dex']}) - Liquidity: ${pair['liquidity']:,.0f}\n"
                    response += "\n"
                    found_results = True
            except Exception as e:
                logger.error(f"خطأ أثناء البحث في DEX عن {search_term}: {e}")
                # Do not send a message to user here if CEX might have results or if other errors occur

            if not found_results:
                response += "❌ لم يتم العثور على نتائج للبحث."

            await update.message.reply_text(response, parse_mode='Markdown')

        except Exception as e:
            # Catch-all for unexpected errors during the command execution
            logger.error(f"خطأ غير متوقع في أمر البحث عن {search_term}: {e}", exc_info=True)
            await update.message.reply_text('⚠️ حدث خطأ غير متوقع أثناء معالجة طلبك. حاول مرة أخرى.')

    async def chart(self, update: Update, context):
        """أمر عرض الرسم البياني"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['chart'] += 1
            user_id = str(update.effective_user.id)
            current_theme = self.user_chart_themes.get(user_id, 'light')

            symbol_input = context.args[0] if context.args else 'BTC'
            parsed_symbol = self._parse_symbol(symbol_input)
            initial_timeframe = '15m' # Default timeframe for initial chart

            df = await self.fetch_ohlcv(parsed_symbol, initial_timeframe)
            if df is None:
                await update.message.reply_text(
                    f"⚠️ Could not fetch data for {parsed_symbol}. Please try again.",
                    parse_mode='Markdown'
                )
                return

            # Apply theme for plotting
            if current_theme == 'dark':
                plt.style.use('dark_background')
                line_color, grid_alpha, edge_color = 'cyan', 0.4, 'white'
            else:
                plt.style.use('default') # Or 'seaborn-v0_8-whitegrid'
                line_color, grid_alpha, edge_color = '#2E86AB', 0.3, 'black'

            plt.figure(figsize=(12, 6))
            quote_currency = parsed_symbol.split('/')[1] if '/' in parsed_symbol else 'USDT'
            plt.plot(df['timestamp'], df['close'], label='Price', linewidth=2, color=line_color)

            title_color = edge_color if current_theme == 'dark' else 'black'
            plt.title(f'{parsed_symbol} - Chart ({initial_timeframe})', fontsize=16, fontweight='bold', color=title_color)
            plt.xlabel('Time', color=title_color)
            plt.ylabel(f'Price ({quote_currency})', color=title_color)
            plt.tick_params(axis='x', colors=edge_color)
            plt.tick_params(axis='y', colors=edge_color)

            legend = plt.legend()
            for text in legend.get_texts():
                text.set_color(edge_color)
            plt.grid(True, alpha=grid_alpha)
            plt.tight_layout()

            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
            buf.seek(0)
            plt.close('all')

            keyboard_tf = [
                [
                    InlineKeyboardButton("1m", callback_data=f"charttf_{parsed_symbol}_1m"),
                    InlineKeyboardButton("5m", callback_data=f"charttf_{parsed_symbol}_5m"),
                    InlineKeyboardButton("15m", callback_data=f"charttf_{parsed_symbol}_15m")
                ],
                [
                    InlineKeyboardButton("1h", callback_data=f"charttf_{parsed_symbol}_1h"),
                    InlineKeyboardButton("4h", callback_data=f"charttf_{parsed_symbol}_4h"),
                    InlineKeyboardButton("1d", callback_data=f"charttf_{parsed_symbol}_1d")
                ]
            ]
            theme_button_text = "🌙 Dark Mode" if current_theme == 'light' else "☀️ Light Mode"
            next_theme = 'dark' if current_theme == 'light' else 'light'
            theme_callback_data = f"charttheme_{parsed_symbol}_{initial_timeframe}_{next_theme}"
            keyboard_theme_row = [InlineKeyboardButton(theme_button_text, callback_data=theme_callback_data)]

            reply_markup = InlineKeyboardMarkup(keyboard_tf + [keyboard_theme_row])
            caption = f"📊 **Chart for {parsed_symbol} ({initial_timeframe})**\nTheme: {current_theme.capitalize()}\nSelect timeframe or mode:"

            await update.message.reply_photo(
                photo=buf,
                caption=caption,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

        except Exception as e:
            logger.error(f"Error in /chart command for {parsed_symbol}: {e}", exc_info=True)
            await update.message.reply_text("⚠️ An error occurred while generating the chart.")

    async def handle_chart_callback(self, update: Update, context):
        """Handles callbacks for chart timeframe and theme changes."""
        try:
            query = update.callback_query
            await query.answer()
            user_id = str(query.from_user.id)

            data = query.data.split('_')
            callback_type = data[0]
            symbol = data[1]

            current_timeframe = data[2] # This is the timeframe of the chart WHEN THE BUTTON WAS PRESSED
            new_theme_for_button_cycle = None

            if callback_type == 'charttheme':
                new_theme = data[3]
                self.user_chart_themes[user_id] = new_theme
                current_theme_for_plot = new_theme
                # Timeframe remains the same as the current chart
                timeframe_for_plot = current_timeframe
                new_theme_for_button_cycle = 'dark' if new_theme == 'light' else 'light'

            elif callback_type == 'charttf':
                new_timeframe = data[2] # For charttf, the third element is the new timeframe
                timeframe_for_plot = new_timeframe
                current_theme_for_plot = self.user_chart_themes.get(user_id, 'light')
                new_theme_for_button_cycle = 'dark' if current_theme_for_plot == 'light' else 'light'
                current_timeframe = new_timeframe # Update current_timeframe for the caption and next theme button
            else:
                logger.warning(f"Unknown chart callback type: {query.data}")
                return

            df = await self.fetch_ohlcv(symbol, timeframe_for_plot)
            if df is None:
                await query.edit_message_text( # Use edit_message_text for error if media can't be updated
                    f"⚠️ Could not fetch data for {symbol} ({timeframe_for_plot}). Please try again."
                )
                return

            # Apply theme for plotting
            if current_theme_for_plot == 'dark':
                plt.style.use('dark_background')
                line_color, grid_alpha, edge_color = 'cyan', 0.4, 'white'
            else:
                plt.style.use('default')
                line_color, grid_alpha, edge_color = '#2E86AB', 0.3, 'black'

            plt.figure(figsize=(12, 6))
            quote_currency = symbol.split('/')[1] if '/' in symbol else 'USDT'
            plt.plot(df['timestamp'], df['close'], label='Price', linewidth=2, color=line_color)

            title_color = edge_color if current_theme_for_plot == 'dark' else 'black'
            plt.title(f'{symbol} - Chart ({timeframe_for_plot})', fontsize=16, fontweight='bold', color=title_color)
            plt.xlabel('Time', color=title_color)
            plt.ylabel(f'Price ({quote_currency})', color=title_color)
            plt.tick_params(axis='x', colors=edge_color)
            plt.tick_params(axis='y', colors=edge_color)

            legend = plt.legend()
            for text in legend.get_texts():
                text.set_color(edge_color)
            plt.grid(True, alpha=grid_alpha)
            plt.tight_layout()

            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
            buf.seek(0)
            plt.close('all')

            keyboard_tf_rows = [
                [
                    InlineKeyboardButton("1m", callback_data=f"charttf_{symbol}_1m"),
                    InlineKeyboardButton("5m", callback_data=f"charttf_{symbol}_5m"),
                    InlineKeyboardButton("15m", callback_data=f"charttf_{symbol}_15m")
                ],
                [
                    InlineKeyboardButton("1h", callback_data=f"charttf_{symbol}_1h"),
                    InlineKeyboardButton("4h", callback_data=f"charttf_{symbol}_4h"),
                    InlineKeyboardButton("1d", callback_data=f"charttf_{symbol}_1d")
                ]
            ]
            theme_button_text = "🌙 Dark Mode" if current_theme_for_plot == 'light' else "☀️ Light Mode"
            # The theme button should always use the currently displayed timeframe (timeframe_for_plot)
            theme_callback_data = f"charttheme_{symbol}_{timeframe_for_plot}_{new_theme_for_button_cycle}"
            keyboard_theme_row = [InlineKeyboardButton(theme_button_text, callback_data=theme_callback_data)]

            reply_markup = InlineKeyboardMarkup(keyboard_tf_rows + [keyboard_theme_row])

            caption = f"📊 **Chart for {symbol} ({timeframe_for_plot})**\nTheme: {current_theme_for_plot.capitalize()}\nSelect timeframe or mode:"

            await query.message.edit_media(
                media=InputMediaPhoto(buf),
                reply_markup=reply_markup
            )
            # Edit caption separately if needed, though edit_media can take caption
            await query.message.edit_caption(caption=caption, parse_mode='Markdown', reply_markup=reply_markup)

        except Exception as e:
            logger.error(f"Error handling chart callback: {e}", exc_info=True)
            # Try to edit the message text if media editing fails or as a fallback
            try:
                await query.edit_message_text("⚠️ An error occurred while updating the chart.")
            except:
                pass # If editing text also fails, nothing more to do

    async def running(self, update: Update, context):
        """أمر فحص حالة البوت"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['running'] += 1

            health_status = await self.health_check_system()
            status_emoji = "🟢" if health_status == "healthy" else "🟡" if health_status == "degraded" else "🔴"

            await update.message.reply_text(
                f"{status_emoji} **البوت يعمل!** 🚀\n"
                f"📊 الحالة: {health_status}\n"
                f"🕒 الوقت: {datetime.now().strftime('%I:%M %p')}\n"
                f"📍 المجموعة النشطة: {self.admin_settings.get('active_group_name', 'غير محددة')}",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"خطأ في فحص حالة البوت: {e}")

    def _format_price(self, price: float) -> str:
        """تنسيق السعر بشكل مناسب"""
        if price < 0.000001:
            return f"{price:.10f}"
        elif price < 0.01:
            return f"{price:.8f}"
        elif price < 1:
            return f"{price:.6f}"
        elif price < 100:
            return f"{price:.4f}"
        elif price < 1000:
            return f"{price:.2f}"
        else:
            return f"{price:,.2f}"

    def _parse_amount_and_symbol(self, text: str) -> Optional[Tuple[float, str]]:
        """تحليل النص للحصول على الكمية والرمز"""
        try:
            # تقسيم النص إلى كلمات
            parts = text.strip().lower().split()
            if len(parts) != 2:
                return None

            # تحليل الكمية
            amount = float(parts[0])
            if amount <= 0:
                return None

            # تحليل الرمز
            symbol = parts[1].upper()
            return amount, symbol

        except (ValueError, IndexError):
            return None

    async def _calculate_value(self, amount: float, symbol: str) -> Optional[Dict]:
        """حساب القيمة بالدولار الأمريكي"""
        try:
            # تحليل الرمز
            parsed_symbol = self._parse_symbol(symbol)

            # البحث عن السعر في CEX
            cex_price = await self.fetch_current_price(parsed_symbol)
            if cex_price:
                return {
                    'platform': 'CEX',
                    'price': cex_price['last'],
                    'total': amount * cex_price['last']
                }

            # البحث عن السعر في DEX
            dex_prices = await self.fetch_dex_price(parsed_symbol)
            if dex_prices and len(dex_prices) > 0:
                best_price = max(dex_prices, key=lambda x: x['price'])
                return {
                    'platform': 'DEX',
                    'price': best_price['price'],
                    'total': amount * best_price['price']
                }

            return None
        except Exception as e:
            logger.error(f"خطأ في حساب القيمة: {e}")
            return None

    async def handle_text(self, update: Update, context):
        """معالجة الرسائل النصية"""
        try:
            if not update or not update.message:
                return

            if not await self.check_access(update):
                return

            text = update.message.text
            if not text:
                return

            text = text.strip()

            # معالجة الكمية والرمز (مثل "2 btc")
            amount_symbol = self._parse_amount_and_symbol(text)
            if amount_symbol:
                amount, symbol = amount_symbol
                result = await self._calculate_value(amount, symbol)
                if result:
                    message = (
                        f"💰 **{amount} {symbol}**:\n"
                        f"💵 `${self._format_price(result['total'])} USD`\n"
                        f"📊 السعر: `${self._format_price(result['price'])}`\n"
                        f"🏦 المنصة: {result['platform']}\n"
                    )
                    await update.message.reply_text(message, parse_mode='Markdown')
                    return

            # معالجة الأوامر العربية
            if text.startswith("سعر "):
                self.command_usage['price_text'] += 1
                symbol_input = text[4:].strip()  # إزالة "سعر "
                await self._get_price_and_reply(update, context, symbol_input)
                return

            elif text.startswith("بحث "):
                self.command_usage['search_text'] += 1
                search_term = text[4:].strip()  # إزالة "بحث "
                context.args = [search_term] if search_term else []
                await self.search(update, context)
                return

            elif text.startswith("رسم "):
                self.command_usage['chart_text'] += 1
                symbol_input = text[3:].strip()  # إزالة "رسم "
                context.args = [symbol_input] if symbol_input else []
                await self.chart(update, context)
                return

            elif text.lower() == "مساعدة":
                await self.help(update, context)
                return

            elif text.lower() == "حالة":
                await self.running(update, context)
                return

            elif self.waiting_for_group_id and str(update.effective_user.id) == self.config['admin_id']:
                await self.handle_group_id(update, context)
                return

            # معالجة رمز العملة المباشر (مثل BTC, ETH)
            if len(text.split()) == 1 and text.isalpha() and len(text) <= 10:
                await self._get_price_and_reply(update, context, text)
                return

        except Exception as e:
            error_msg = f"خطأ في معالجة النص: {e}"
            logger.error(error_msg) # TelegramErrorHandler will pick this up

    async def clean_cache(self):
        """تنظيف البيانات المؤقتة المنتهية الصلاحية"""
        try:
            current_time = time.time()
            expired = [key for key, (_, timestamp) in self.cached_data.items()
                      if current_time - timestamp > 3600]

            for key in expired:
                del self.cached_data[key]

            if expired:
                event_logger.info(f"تم تنظيف {len(expired)} عنصر من الذاكرة المؤقتة")

        except Exception as e:
            logger.error(f"خطأ في تنظيف الذاكرة المؤقتة: {e}")

    async def schedule_cache_cleanup(self):
        """جدولة تنظيف الذاكرة المؤقتة كل ساعة"""
        while True:
            await self.clean_cache()
            await asyncio.sleep(3600)

async def error_handler(update: object, context):
    """معالج الأخطاء العام"""
    try:
        logger.error(f"خطأ في التحديث {update}: {context.error}")

        if isinstance(update, Update) and update.effective_message:
            await update.effective_message.reply_text(
                "⚠️ حدث خطأ غير متوقع. تم تسجيل المشكلة وسيتم إصلاحها قريباً."
            )
    except Exception as e:
        logger.error(f"خطأ في معالج الأخطاء: {e}")

async def main():
    """الدالة الرئيسية لتشغيل البوت"""
    application = None
    bot = None

    try:
        # إعداد البوت
        bot = TradingBot(CONFIG)
        application = Application.builder().token(CONFIG['telegram_token']).build()
        bot.application = application

        # Provider function for the TelegramErrorHandler
        def get_bot_app():
            return application

        if CONFIG.get('error_group_id'):
            telegram_error_handler = TelegramErrorHandler(get_bot_app, CONFIG['error_group_id'])
            telegram_error_handler.setLevel(logging.ERROR) # Set level for this handler
            telegram_error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')) # Use the same formatter

            logger.addHandler(telegram_error_handler)
            bot.telegram_error_handler = telegram_error_handler # Store it on the bot instance

            # Process any messages that were queued before the application was ready
            telegram_error_handler.process_pending_messages()

        # Setup for TelegramEventLogHandler
        if CONFIG.get('event_group_id'):
            telegram_event_log_handler = TelegramEventLogHandler(get_bot_app, CONFIG['event_group_id'])
            # Events are typically INFO level. The event_logger itself is set to INFO.
            telegram_event_log_handler.setLevel(logging.INFO)
            # Use the same formatter as the file handler for events, or a simpler one if desired.
            # Current event_handler format: logging.Formatter('%(asctime)s - %(message)s')
            telegram_event_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))

            event_logger.addHandler(telegram_event_log_handler)
            bot.telegram_event_log_handler = telegram_event_log_handler

            # Process any messages that were queued before the application was ready
            telegram_event_log_handler.process_pending_messages()

        # إضافة معالجات الأوامر
        application.add_handler(CommandHandler("start", bot.start))
        application.add_handler(CommandHandler("help", bot.help))
        application.add_handler(CommandHandler("price", bot.price))
        application.add_handler(CommandHandler("search", bot.search))
        application.add_handler(CommandHandler("chart", bot.chart))
        application.add_handler(CommandHandler("running", bot.running))
        application.add_handler(CommandHandler("admin", bot.admin_panel))
        application.add_handler(CallbackQueryHandler(bot.handle_admin_callback, pattern="^admin_"))
        application.add_handler(CallbackQueryHandler(bot.handle_chart_callback, pattern="^chart(tf|theme)_"))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_text))

        # إعداد معالجة الأخطاء
        application.add_error_handler(error_handler)

        # تشغيل البوت
        logger.info("جاري تشغيل البوت...")
        await bot.send_to_log_group("🚀 تم تشغيل البوت بنجاح!")

        # تشغيل تنظيف الذاكرة المؤقتة في الخلفية
        asyncio.create_task(bot.schedule_cache_cleanup())

        # تشغيل البوت
        await application.initialize()
        await application.start()

        # تشغيل البوت في وضع الاستماع
        await application.updater.start_polling()

        # انتظار الإشارة للإيقاف
        try:
            while True:
                await asyncio.sleep(1)
        except asyncio.CancelledError:
            pass

    except Exception as e:
        error_msg = f"خطأ في تشغيل البوت: {e}\n{traceback.format_exc()}"
        logger.error(error_msg) # TelegramErrorHandler will pick this up if logger is configured before this point.
                                # If main fails very early, this log might not make it to Telegram.
        # The direct call to bot.send_to_error_group is removed.
        # If the TelegramErrorHandler is successfully set up, it will handle sending this to Telegram.
    finally:
        if application:
            try:
                await application.updater.stop()
                await application.stop()
                await application.shutdown()
            except Exception as shutdown_error:
                logger.error(f"خطأ في إغلاق البوت: {shutdown_error}")

def run_bot():
    """تشغيل البوت مع معالجة الأخطاء"""
    try:
        # إعداد معالجة الأخطاء غير المتوقعة
        sys.excepthook = lambda exc_type, exc_value, exc_traceback: logger.error(
            f"خطأ غير متوقع: {exc_value}\n{''.join(traceback.format_tb(exc_traceback))}"
        )

        # تشغيل البوت
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("تم إيقاف البوت بواسطة المستخدم")
    except Exception as e:
        error_msg = f"خطأ في تشغيل البرنامج: {e}\n{traceback.format_exc()}"
        logger.error(error_msg)
        print(f"خطأ فادح: {error_msg}")

if __name__ == '__main__':
    run_bot()