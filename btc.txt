import sys
import json
import asyncio
import os
import logging
from logging.handlers import RotatingFileHandler
import traceback
from typing import Optional, Tuple, Dict, List
import ccxt.async_support as ccxt
import aiohttp
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import io
import time
from collections import defaultdict
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import BadRequest, Forbidden
from telegram import InputMediaPhoto
from tenacity import retry, stop_after_attempt, wait_fixed
import portalocker
import ta
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Error logger
error_handler = RotatingFileHandler('errors.log', mode='a', maxBytes=10*1024*1024, backupCount=5)
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(error_handler)

# Event logger
event_handler = RotatingFileHandler('events.log', mode='a', maxBytes=10*1024*1024, backupCount=5)
event_handler.setLevel(logging.INFO)
event_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
event_logger = logging.getLogger('events')
event_logger.addHandler(event_handler)
event_logger.setLevel(logging.INFO)
try:
    with open('config.json', 'r') as f:
        CONFIG = json.load(f)
except FileNotFoundError:
    print("FATAL ERROR: config.json not found. Please ensure the configuration file exists.")
    sys.exit(1)
except json.JSONDecodeError:
    print("FATAL ERROR: config.json is not valid JSON. Please check the file content.")
    sys.exit(1)

# Configuration

class RateLimiter:
    def __init__(self):
        self.user_requests = defaultdict(list)
        self.banned_users = {}
        self.MAX_REQUESTS = 30
        self.WARNING_THRESHOLD = 20
        self.TIME_WINDOW = 60
        self.BAN_DURATION = 3600

    def check_rate_limit(self, user_id: str) -> Tuple[bool, Optional[str]]:
        current_time = time.time()

        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        self.user_requests[user_id] = [
            t for t in self.user_requests[user_id]
            if current_time - t < self.TIME_WINDOW
        ]
        self.user_requests[user_id].append(current_time)

        # ÙØ­Øµ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
        if user_id in self.banned_users:
            ban_time = self.banned_users[user_id]
            if current_time - ban_time < self.BAN_DURATION:
                remaining = int(self.BAN_DURATION - (current_time - ban_time))
                return False, f"ğŸš« **ØªÙ… Ø­Ø¸Ø±Ùƒ** Ù„Ù…Ø¯Ø© {remaining // 60} Ø¯Ù‚ÙŠÙ‚Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø­Ø¸Ø±."
            else:
                del self.banned_users[user_id]
                self.user_requests[user_id].clear()

        # ÙØ­Øµ Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        if len(self.user_requests[user_id]) > self.MAX_REQUESTS:
            self.banned_users[user_id] = current_time
            return False, f"ğŸš« **ØªÙ… Ø­Ø¸Ø±Ùƒ** Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø­Ø¸Ø±."
        elif len(self.user_requests[user_id]) > self.WARNING_THRESHOLD:
            return True, f"âš ï¸ **ØªØ­Ø°ÙŠØ±**: Ø£Ù†Øª ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¨ÙˆØª Ø¨Ø³Ø±Ø¹Ø© ÙƒØ¨ÙŠØ±Ø©!\nğŸ“Œ Ù„Ùˆ Ø§Ø³ØªÙ…Ø± Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·ØŒ Ø³ÙŠØªÙ… Ø­Ø¸Ø±Ùƒ Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø©."

        return True, None

class TelegramErrorHandler(logging.Handler):
    def __init__(self, bot_app_provider, error_group_id):
        super().__init__()
        self.bot_app_provider = bot_app_provider  # This will be a function/lambda to get the bot app
        self.error_group_id = error_group_id
        self.pending_messages = []

    async def send_message_async(self, text_message):
        application = self.bot_app_provider()
        if application and self.error_group_id:
            try:
                # Clean message from markdown characters that might break the formatting
                clean_message = text_message.replace('`', '').replace('*', '').replace('_', '')
                # Split message if too long
                max_length = 4000  # Telegram message length limit
                if len(clean_message) > max_length:
                    parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]
                    for part in parts:
                        await application.bot.send_message(
                            chat_id=self.error_group_id,
                            text=f"âš ï¸ **Error Log**:\n```\n{part}\n```",
                            parse_mode='Markdown'
                        )
                else:
                    await application.bot.send_message(
                        chat_id=self.error_group_id,
                        text=f"âš ï¸ **Error Log**:\n```\n{clean_message}\n```",
                        parse_mode='Markdown'
                    )
            except Exception as e:
                # Use the main logger to log an error if sending to Telegram fails,
                # to avoid recursion if this handler is itself causing an error.
                # Get the root logger to avoid self-referential logging if 'logger' is the one this handler is attached to.
                logging.getLogger().error(f"TelegramErrorHandler failed to send message: {e}", exc_info=True)

    def process_pending_messages(self):
        application = self.bot_app_provider()
        if application:
            while self.pending_messages:
                message = self.pending_messages.pop(0)
                asyncio.create_task(self.send_message_async(message))

    def emit(self, record):
        if not self.error_group_id: # Do nothing if error_group_id is not set
            return

        log_message = self.format(record)
        application = self.bot_app_provider()

        if application and application.bot:
            self.process_pending_messages() # Process any backlog
            asyncio.create_task(self.send_message_async(log_message))
        else:
            self.pending_messages.append(log_message)

class TelegramEventLogHandler(logging.Handler):
    def __init__(self, bot_app_provider, event_group_id):
        super().__init__()
        self.bot_app_provider = bot_app_provider
        self.event_group_id = event_group_id
        self.pending_messages = []

    async def send_message_async(self, text_message):
        application = self.bot_app_provider()
        if application and self.event_group_id:
            try:
                # Clean message from markdown characters that might break the formatting
                # For event logs, we might want to keep some markdown if used deliberately.
                # However, for consistency with error handler and safety:
                clean_message = text_message.replace('`', '').replace('*', '').replace('_', '')

                # Split message if too long
                max_length = 4000  # Telegram message length limit
                # Add a prefix to distinguish event logs
                prefix = "ğŸ”” **Event Log**:\n"

                if len(prefix + clean_message) > max_length:
                    # If the message itself is too long, truncate or split
                    # For simplicity, let's send it as is and rely on Telegram's handling or truncate
                    # A more robust way would be to split like in TelegramErrorHandler
                    parts = [clean_message[i:i+max_length-len(prefix)] for i in range(0, len(clean_message), max_length-len(prefix))]
                    for part in parts:
                            await application.bot.send_message(
                            chat_id=self.event_group_id,
                            text=f"{prefix}{part}",
                            parse_mode='Markdown' # Or None if we don't want markdown for events
                        )
                else:
                        await application.bot.send_message(
                        chat_id=self.event_group_id,
                        text=f"{prefix}{clean_message}",
                        parse_mode='Markdown' # Or None
                    )
            except Exception as e:
                logging.getLogger().error(f"TelegramEventLogHandler failed to send message: {e}", exc_info=True)

    def process_pending_messages(self):
        application = self.bot_app_provider()
        if application:
            while self.pending_messages:
                message = self.pending_messages.pop(0)
                asyncio.create_task(self.send_message_async(message))

    def emit(self, record):
        if not self.event_group_id: # Do nothing if event_group_id is not set
            return

        log_message = self.format(record) # Get the formatted message
        # The default event logger format is '%(asctime)s - %(message)s'
        # We might want to send only record.getMessage() if the formatter is too verbose for Telegram
        # For now, let's use the formatted message.

        application = self.bot_app_provider()

        if application and application.bot:
            self.process_pending_messages()
            asyncio.create_task(self.send_message_async(log_message))
        else:
            self.pending_messages.append(log_message)

class TradingBot:
    def __init__(self, config: Dict[str, str]):
        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØª"""
        self.config = config
        self.exchange = None
        self.application = None
        self.cached_data = {}
        self.waiting_for_group_id = False
        self.command_usage = defaultdict(int)
        self.rate_limiter = RateLimiter()
        self.last_cache_cleanup = time.time()
        self.telegram_error_handler = None
        self.telegram_event_log_handler = None
        self.user_chart_themes = {}

        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
        self.admin_settings = {
            'private_enabled': True,
            'active_group_id': self.config.get('default_group_id', ''),
            'active_group_name': 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©'
        }

        # ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        self.features = [
            'RSI_14', 'RSI_7', 'RSI_21', 'MACD', 'MACD_signal', 'Bollinger_width',
            'ATR_14', 'ATR_7', 'Stochastic', 'Volume_MA_20', 'Volume_MA_50',
            'MA_5', 'MA_10', 'MA_20', 'MA_50', 'MA_200', 'EMA_12', 'EMA_26', 'EMA_50'
        ]

        # ØªØ¹Ø±ÙŠÙ Ù…Ø¯Ø¯ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ø²Ù…Ù†ÙŠØ©
        self.timeframe_durations = {
            '1m': timedelta(minutes=1),
            '5m': timedelta(minutes=5),
            '15m': timedelta(minutes=15),
            '30m': timedelta(minutes=30),
            '1h': timedelta(hours=1),
            '4h': timedelta(hours=4),
            '1d': timedelta(days=1),
            '1w': timedelta(weeks=1)
        }

        self.health_check = {
            'last_check': time.time(),
            'status': 'healthy',
            'errors': []
        }

        self.fallback_config = {
            'use_cache': True,
            'retry_attempts': 3,
            'timeout': 30,
            'max_errors': 5
        }

    async def health_check_system(self):
        """ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø¨ÙˆØª"""
        try:
            current_time = time.time()
            if current_time - self.health_check['last_check'] < 300:  # ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
                return self.health_check['status']

            # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©
            if not self.exchange:
                if not await self.init_exchange():
                    self.health_check['status'] = 'degraded'
                    self.health_check['errors'].append('ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©')
                    return 'degraded'

            # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
            if self.application:
                try:
                    await self.application.bot.get_me()
                except Exception as e:
                    self.health_check['status'] = 'degraded'
                    self.health_check['errors'].append(f'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…: {e}')
                    return 'degraded'

            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
            self.health_check['last_check'] = current_time
            self.health_check['status'] = 'healthy'
            self.health_check['errors'] = []
            return 'healthy'

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„ØµØ­Ø©: {e}")
            self.health_check['status'] = 'degraded'
            self.health_check['errors'].append(str(e))
            return 'degraded'

    async def init_exchange(self) -> bool:
        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ© Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø§Ø³ØªØ¹Ø§Ø¯Ø©"""
        try:
            if self.exchange:
                try:
                    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
                    await self.exchange.fetch_status()
                    return True
                except:
                    # Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ØŒ Ø£Ø¹Ø¯ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
                    self.exchange = None

            # Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ©
            self.exchange = ccxt.mexc({
                'enableRateLimit': True,
                'timeout': self.fallback_config['timeout'] * 1000,
                'sandbox': False
            })

            # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„
            await self.exchange.load_markets()
            logger.info("ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ© Ø¨Ù†Ø¬Ø§Ø­")
            return True

        except Exception as e:
            logger.error(f"ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ©: {e}")
            self.exchange = None
            return False

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1m', limit: int = 500) -> Optional[pd.DataFrame]:
        """Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª OHLCV Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø§Ø³ØªØ¹Ø§Ø¯Ø©"""
        try:
            # ÙØ­Øµ Ø§Ù„ØµØ­Ø©
            if await self.health_check_system() == 'degraded':
                logger.warning(f"Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ù…ØªØ¯Ù‡ÙˆØ±Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù€ {symbol}")
                return self._get_cached_data(symbol, timeframe)

            if not self.exchange:
                if not await self.init_exchange():
                    return self._get_cached_data(symbol, timeframe)

            # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            async with asyncio.timeout(self.fallback_config['timeout']):
                ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
                if not ohlcv:
                    return self._get_cached_data(symbol, timeframe)

            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

            # Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            self._cache_data(symbol, timeframe, df)
            return df

        except asyncio.TimeoutError:
            logger.warning(f"Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª {symbol}")
            return self._get_cached_data(symbol, timeframe)
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª {symbol}: {e}")
            return self._get_cached_data(symbol, timeframe)

    def _get_cached_data(self, symbol: str, timeframe: str) -> Optional[pd.DataFrame]:
        """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªØ§Ù‹"""
        cache_key = f"{symbol}:{timeframe}"
        if cache_key in self.cached_data:
            cached, timestamp = self.cached_data[cache_key]
            if (time.time() - timestamp) < 300:  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
                return cached
        return None

    def _cache_data(self, symbol: str, timeframe: str, df: pd.DataFrame):
        """ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¤Ù‚ØªØ§Ù‹"""
        cache_key = f"{symbol}:{timeframe}"
        self.cached_data[cache_key] = (df, time.time())

    def _parse_symbol(self, input_symbol: str) -> str:
        """ØªØ­Ù„ÙŠÙ„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©"""
        try:
            if not input_symbol or not isinstance(input_symbol, str):
                return self.config['default_symbol']

            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±Ù…Ø²
            symbol = input_symbol.strip().upper()

            if not symbol:
                return self.config['default_symbol']

            # Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /
            if '/' in symbol:
                parts = symbol.split('/')
                if len(parts) == 2 and parts[0] and parts[1]:
                    return symbol
                else:
                    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ­ÙŠØ­
                    base = parts[0] if parts[0] else 'BTC'
                    return f"{base}/USDT"
            else:
                # Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /ØŒ Ø£Ø¶Ù USDT Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
                return f"{symbol}/USDT"

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø©: {e}")
            return self.config['default_symbol']

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_current_price(self, symbol: str) -> Optional[Dict]:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø¹Ù…Ù„Ø©"""
        try:
            if not symbol or not isinstance(symbol, str):
                logger.error(f"Ø±Ù…Ø² Ø¹Ù…Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­: {symbol}")
                return None

            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø² Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­ØªÙ‡
            parsed_symbol = self._parse_symbol(symbol)

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø²
            if len(parsed_symbol.split('/')) != 2:
                logger.error(f"ØªÙ†Ø³ÙŠÙ‚ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­: {symbol}")
                return None

            if not self.exchange:
                if not await self.init_exchange():
                    return None

            ticker = await self.exchange.fetch_ticker(parsed_symbol)
            if not ticker or 'last' not in ticker:
                logger.error(f"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {parsed_symbol}")
                return None

            return {
                'last': float(ticker['last']),
                'percentage': float(ticker.get('percentage', 0)),
                'high': float(ticker.get('high', 0)),
                'low': float(ticker.get('low', 0)),
                'volume': float(ticker.get('baseVolume', 0)),
                'symbol': parsed_symbol
            }

        except ccxt.NetworkError as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")
            return None
        except ccxt.ExchangeError as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙˆØ±ØµØ© Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")
            return None
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")
            return None

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
    async def fetch_dex_price(self, symbol: str) -> Optional[List[Dict]]:
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù…Ù† Ù…Ù†ØµØ§Øª DEX"""
        try:
            async with asyncio.timeout(10):
                # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø² Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†
                if '/' in symbol:
                    base, quote = symbol.split('/', 1)  # Ø§Ø³ØªØ®Ø¯Ø§Ù… maxsplit=1
                else:
                    # Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /, Ø§ÙØªØ±Ø¶ USDT ÙƒØ¹Ù…Ù„Ø© Ù…Ù‚Ø§Ø¨Ù„Ø©
                    base = symbol
                    quote = 'USDT'

                url = f"https://api.dexscreener.com/latest/dex/search?q={base}"

                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=10) as response:
                        response.raise_for_status()
                        data = await response.json()

                pairs = []
                for pair in data.get('pairs', []):
                    if pair.get('quoteToken', {}).get('symbol', '').upper() == quote.upper():
                        pairs.append({
                            'price': float(pair.get('priceUsd', 0)),
                            'dex': pair.get('dexId', 'Unknown'),
                            'liquidity': float(pair.get('liquidity', {}).get('usd', 0)),
                            'volume_24h': float(pair.get('volume', {}).get('h24', 0)), # Renamed
                            'change_24h': float(pair.get('priceChange', {}).get('h24', 0)),
                            'change_1h': float(pair.get('priceChange', {}).get('h1', 0)),   # New
                            'market_cap': float(pair.get('fdv', 0)) # New, from 'fdv'
                        })

                # Sort by liquidity to get the most relevant pair first potentially
                if pairs:
                    pairs.sort(key=lambda x: x['liquidity'], reverse=True)
                return pairs if pairs else None

        except Exception as e:
            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø³Ø¹Ø± {symbol} Ù…Ù† DEX: {e}"
            logger.error(error_msg)
            # Removed: asyncio.create_task(self.send_to_error_group(error_msg))
            # logger.error should now trigger TelegramErrorHandler
            return None

    async def send_to_log_group(self, message: str):
        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª"""
        try:
            if self.application and self.config.get('log_group_id'):
                await self.application.bot.send_message(
                    chat_id=self.config['log_group_id'],
                    text=message,
                    parse_mode='Markdown'
                )
        except (BadRequest, Forbidden) as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¬Ù„ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª: {e}")

    async def send_to_error_group(self, message: str):
        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
        try:
            if not self.application or not self.config.get('error_group_id'):
                return

            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø®Ø§ØµØ©
            clean_message = message.replace('`', '').replace('*', '').replace('_', '')

            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹
            max_length = 4000
            if len(clean_message) > max_length:
                parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]
                for part in parts:
                    await self.application.bot.send_message(
                        chat_id=self.config['error_group_id'],
                        text=f"âš ï¸ **Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n```\n{part}\n```",
                        parse_mode='Markdown'
                    )
            else:
                await self.application.bot.send_message(
                    chat_id=self.config['error_group_id'],
                    text=f"âš ï¸ **Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n```\n{clean_message}\n```",
                    parse_mode='Markdown'
                )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {e}")

    # The send_to_error_group method is now removed.
    # Its functionality is replaced by the TelegramErrorHandler.

    async def check_access(self, update: Update) -> bool:
        """ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        try:
            user_id = str(update.effective_user.id)
            chat_id = str(update.effective_chat.id)
            is_private = update.effective_chat.type == 'private'
            is_admin = user_id == self.config['admin_id']

            if is_admin:
                return True

            # ÙØ­Øµ Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
            allowed, message = self.rate_limiter.check_rate_limit(user_id)
            if not allowed:
                await update.message.reply_text(message, parse_mode='Markdown')
                if "ØªÙ… Ø­Ø¸Ø±Ùƒ" in message:
                    # This was a direct call to send_to_error_group.
                    # Now, we should log an error, and the handler will pick it up.
                    logger.error(
                        f"User {update.effective_user.first_name} (ID: {user_id}) banned for rate limiting."
                    )
                return False

            # ÙØ­Øµ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©
            if is_private and not self.admin_settings['private_enabled']:
                await update.message.reply_text(
                    "âš ï¸ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙÙ„Øª Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ© Ø­Ø§Ù„ÙŠÙ‹Ø§.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§ Ø£Ùˆ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø£Ø¯Ù…Ù†.",
                    parse_mode='Markdown'
                )
                return False

            # ÙØ­Øµ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©
            if not is_private and self.admin_settings.get('active_group_id') and chat_id != self.admin_settings['active_group_id']:
                return False

            # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯Øª
            if message:
                await update.message.reply_text(message, parse_mode='Markdown')

            return True
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©: {e}")
            return False

    async def admin_panel(self, update: Update, context):
        """Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†"""
        try:
            if str(update.effective_user.id) != self.config['admin_id']:
                await update.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·!", parse_mode='Markdown')
                return

            keyboard = [
                [
                    InlineKeyboardButton(
                        f"{'Ø¥ÙŠÙ‚Ø§Ù' if self.admin_settings['private_enabled'] else 'ØªÙØ¹ÙŠÙ„'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©",
                        callback_data='admin_toggle_private'
                    )
                ],
                [
                    InlineKeyboardButton("ØªØ¹ÙŠÙŠÙ† Ù…Ø¬Ù…ÙˆØ¹Ø©", callback_data='admin_set_group')
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            status_msg = (
                f"ğŸ› ï¸ **Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†** ğŸ› ï¸\n\n"
                f"ğŸ“± Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©: {'Ù…ÙØ¹Ù„Ø©' if self.admin_settings['private_enabled'] else 'Ù…Ù‚ÙÙ„Ø©'}\n"
                f"ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©: {self.admin_settings['active_group_name']}\n"
                f"âš¡ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: {await self.health_check_system()}\n\n"
                f"Ø§Ø®ØªØ± Ø¥Ø¹Ø¯Ø§Ø¯Ù‹Ø§ Ù„ØªØ®ØµÙŠØµÙ‡:"
            )

            await update.message.reply_text(
                status_msg,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†: {e}")
            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ….")

    async def handle_admin_callback(self, update: Update, context):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†"""
        try:
            query = update.callback_query
            await query.answer()

            if str(query.from_user.id) != self.config['admin_id']:
                await query.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·!", parse_mode='Markdown')
                return

            data = query.data

            if data == 'admin_toggle_private':
                self.admin_settings['private_enabled'] = not self.admin_settings['private_enabled']
                status = "Ù…ÙØ¹Ù„Ø©" if self.admin_settings['private_enabled'] else "Ù…Ù‚ÙÙ„Ø©"
                await query.message.edit_text(
                    f"âœ… ØªÙ… {'ØªÙØ¹ÙŠÙ„' if self.admin_settings['private_enabled'] else 'Ø¥ÙŠÙ‚Ø§Ù'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©.\nØ§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {status}",
                    parse_mode='Markdown'
                )
                await self.send_to_log_group(f"ØªÙ… {'ØªÙØ¹ÙŠÙ„' if self.admin_settings['private_enabled'] else 'Ø¥ÙŠÙ‚Ø§Ù'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ© Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¯Ù…Ù†.")

            elif data == 'admin_set_group':
                self.waiting_for_group_id = True
                await query.message.edit_text(
                    "ğŸ“Œ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø±Ø³Ù„ ID Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© (Ù…Ø«Ø§Ù„: -1001234567890) Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§.",
                    parse_mode='Markdown'
                )

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø¯Ù…Ù†: {e}")

    async def handle_group_id(self, update: Update, context):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹ÙŠÙŠÙ† ID Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©"""
        try:
            if not self.waiting_for_group_id or str(update.effective_user.id) != self.config['admin_id']:
                return

            group_id = update.message.text.strip()
            chat = await context.bot.get_chat(group_id)

            self.admin_settings['active_group_id'] = group_id
            self.admin_settings['active_group_name'] = chat.title
            self.waiting_for_group_id = False

            await update.message.reply_text(
                f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© **{chat.title}** (ID: {group_id}) Ø¨Ù†Ø¬Ø§Ø­!",
                parse_mode='Markdown'
            )

            await context.bot.send_message(
                chat_id=group_id,
                text=(
                    f"ğŸ‰ **ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© {chat.title}** Ø¨ÙˆØ§Ø³Ø·Ø© {update.effective_user.first_name}! ğŸš€\n"
                    "ğŸ“‹ Ø§Ø³ØªØ®Ø¯Ù… `/help` Ø£Ùˆ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©.\n"
                    "ğŸ’¡ Ø¬Ø§Ù‡Ø² Ù„Ø®Ø¯Ù…ØªÙƒÙ… ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„ØªØ¯Ø§ÙˆÙ„!"
                ),
                parse_mode='Markdown'
            )

            await self.send_to_log_group(f"ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {chat.title} (ID: {group_id}) Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¯Ù…Ù†.")

        except Exception as e:
            await update.message.reply_text(
                f"âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ ID ØµØ­ÙŠØ­ ÙˆØ£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ø¶Ùˆ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.",
                parse_mode='Markdown'
            )
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {group_id}: {e}") # Changed from direct send_to_error_group

    def _format_large_number(self, num: float) -> str:
        if num is None:
            return "N/A"
        if abs(num) >= 1_000_000_000:
            return f"${num / 1_000_000_000:.2f}B"
        elif abs(num) >= 1_000_000:
            return f"${num / 1_000_000:.2f}M"
        elif abs(num) >= 1_000:
            return f"${num / 1_000:.2f}K"
        return f"${num:,.2f}" # Added comma for numbers < 1K but > 0

    def _format_percentage(self, change: Optional[float]) -> str:
        if change is None:
            return "N/A"
        emoji = "ğŸ“ˆ" if change >= 0 else "ğŸ“‰"
        return f"{emoji} {change:+.2f}%"

    async def _get_price_and_reply(self, update: Update, context, requested_arg: Optional[str]):
        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± ÙˆØ§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø©"""
        try:
            if not requested_arg:
                await update.message.reply_text(
                    "âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ø§Ù„: /price BTC Ø£Ùˆ Ø³Ø¹Ø± BTC).",
                    parse_mode='Markdown'
                )
                return

            parsed_symbol_for_cex = self._parse_symbol(requested_arg) # Ensures SYMBOL/USDT format for CEX
            base_currency = requested_arg.split('/')[0].upper() # For DEX search and display name

            reply_message_lines = []
            found_on_cex = False

            # CEX Data Fetching (MEXC)
            if self.exchange or await self.init_exchange():
                try:
                    ticker_data = await self.fetch_current_price(parsed_symbol_for_cex)
                    if ticker_data:
                        found_on_cex = True
                        price = ticker_data['last']
                        display_symbol_cex = ticker_data['symbol']

                        reply_message_lines.append(f"ğŸ’ **{base_currency} ({display_symbol_cex} - MEXC)**")
                        reply_message_lines.append(f"ğŸ’° **Price: `{self._format_price(price)}`**")

                        change_24h_cex = ticker_data.get('percentage')
                        reply_message_lines.append(f"ğŸ“Š 24h Change: {self._format_percentage(change_24h_cex)}")

                        # OHLCV for 1h, 7d, 30d changes
                        # 1h change
                        ohlcv_1h_data = await self.fetch_ohlcv(display_symbol_cex, '1h', limit=1) # Fetch the last completed 1h candle
                        if ohlcv_1h_data and len(ohlcv_1h_data) == 1:
                            price_1h_ago = ohlcv_1h_data[0]['close']
                            change_1h = ((price - price_1h_ago) / price_1h_ago) * 100 if price_1h_ago else None
                            reply_message_lines.append(f"â³ 1h Change: {self._format_percentage(change_1h)}")
                        else:
                            reply_message_lines.append("â³ 1h Change: N/A")

                        # 7d change
                        ohlcv_7d_data = await self.fetch_ohlcv(display_symbol_cex, '1d', limit=7) # Fetch last 7 completed daily candles
                        if ohlcv_7d_data and len(ohlcv_7d_data) == 7:
                            price_7d_ago = ohlcv_7d_data[0]['close'] # Oldest candle is 7 days ago
                            change_7d = ((price - price_7d_ago) / price_7d_ago) * 100 if price_7d_ago else None
                            reply_message_lines.append(f"ğŸ“… 7d Change: {self._format_percentage(change_7d)}")
                        else:
                            reply_message_lines.append("ğŸ“… 7d Change: N/A")

                        # 30d change
                        ohlcv_30d_data = await self.fetch_ohlcv(display_symbol_cex, '1d', limit=30) # Fetch last 30 completed daily candles
                        if ohlcv_30d_data and len(ohlcv_30d_data) == 30:
                            price_30d_ago = ohlcv_30d_data[0]['close'] # Oldest candle is 30 days ago
                            change_30d = ((price - price_30d_ago) / price_30d_ago) * 100 if price_30d_ago else None
                            reply_message_lines.append(f"ğŸ—“ï¸ 30d Change: {self._format_percentage(change_30d)}")
                        else:
                            reply_message_lines.append("ğŸ—“ï¸ 30d Change: N/A")

                        vol_24h_base = ticker_data.get('volume', 0.0)
                        vol_24h_quote = vol_24h_base * price # Approximate quote volume
                        reply_message_lines.append(f"ğŸ“ˆ 24h Volume: {self._format_large_number(vol_24h_quote)}")
                        reply_message_lines.append(f"ğŸ”¼ High 24h: `{self._format_price(ticker_data.get('high'))}`")
                        reply_message_lines.append(f"ğŸ”½ Low 24h: `{self._format_price(ticker_data.get('low'))}`")
                        reply_message_lines.append(f"ğŸ¦ Market Cap: N/A (CEX)") # Market Cap not typically available from CEX ticker
                        reply_message_lines.append(f"ğŸ•’ {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}")
                except Exception as e:
                    logger.error(f"Error fetching or processing CEX data for {parsed_symbol_for_cex}: {e}", exc_info=True)
                    if not found_on_cex: # Only add error if this was the primary attempt
                        reply_message_lines.append(f"â„¹ï¸ CEX data for {parsed_symbol_for_cex} incomplete or unavailable.")

            # DEX Data Fetching (DexScreener) - Try if not found on CEX or as supplemental
            # Use base_currency for DEX search as it's more general
            dex_pairs = await self.fetch_dex_price(base_currency)
            if dex_pairs:
                best_dex_pair = dex_pairs[0] # Already sorted by liquidity in fetch_dex_price

                if found_on_cex:
                    reply_message_lines.append("\n--- Also found on DEX ---")

                reply_message_lines.append(f"ğŸ¦ **{base_currency} (DEX - {best_dex_pair['dex']})**")
                reply_message_lines.append(f"ğŸ’° **Price: `{self._format_price(best_dex_pair['price'])}`**")
                reply_message_lines.append(f"â³ 1h Change: {self._format_percentage(best_dex_pair.get('change_1h'))}")
                reply_message_lines.append(f"ğŸ“Š 24h Change: {self._format_percentage(best_dex_pair.get('change_24h'))}")
                reply_message_lines.append(f"ğŸ“ˆ 24h Volume: {self._format_large_number(best_dex_pair.get('volume_24h'))}")
                reply_message_lines.append(f"ğŸ’§ Liquidity: {self._format_large_number(best_dex_pair.get('liquidity'))}")
                reply_message_lines.append(f"ğŸ¦ Market Cap: {self._format_large_number(best_dex_pair.get('market_cap'))}")
                reply_message_lines.append(f"ğŸ•’ {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}")
            elif not found_on_cex:
                reply_message_lines.append(f"âš ï¸ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {requested_arg} Ù…Ù† Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©.")

            if reply_message_lines:
                await update.message.reply_text("\n".join(reply_message_lines), parse_mode='Markdown')
            # If still no lines (e.g. CEX init failed and DEX failed), the initial error message is sent by price command

        except Exception as e:
            error_msg = f"Ø®Ø·Ø£ Ø´Ø§Ù…Ù„ ÙÙŠ _get_price_and_reply Ù„Ù€ {requested_arg}: {e}"
            logger.error(error_msg, exc_info=True)
            await update.message.reply_text(
                "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙƒØ¨ÙŠØ± Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.",
                parse_mode='Markdown'
            )

    # Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
    async def start(self, update: Update, context):
        """Ø£Ù…Ø± Ø§Ù„Ø¨Ø¯Ø¡"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['start'] += 1
            group_name = self.admin_settings.get('active_group_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©')

            await update.message.reply_text(
                f"ğŸ‘‹ **Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„!** ğŸš€\n"
                f"ğŸ“ˆ Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±ØŒ ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ø³ÙˆÙ‚ØŒ ÙˆÙØ±Øµ Ø§Ù„ØªØ¯Ø§ÙˆÙ„.\n"
                f"ğŸ“ Ø§Ù„Ø¨ÙˆØª Ù…ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: **{group_name}**\n"
                f"ğŸ“‹ Ø§Ø³ØªØ®Ø¯Ù… `/help` Ø£Ùˆ Ø§ÙƒØªØ¨ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©.\n"
                f"ğŸ’¡ Ø¬Ø§Ù‡Ø² Ù„Ø®Ø¯Ù…ØªÙƒ!",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ø¨Ø¯Ø¡: {e}")
            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

    async def help(self, update: Update, context):
        """Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['help'] += 1

            await update.message.reply_text(
                """ğŸ“‹ **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©**:

ğŸ‘‹ `/start` - Ø¨Ø¯Ø¡ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª
ğŸ’° `/price <Ø±Ù…Ø²>` - Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø²ÙˆØ¬ ØªØ¯Ø§ÙˆÙ„ (Ù…Ø«Ø§Ù„: BTC/USDT)
ğŸ” `/search <Ø±Ù…Ø²>` - Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø²ÙˆØ§Ø¬ ØªØ¯Ø§ÙˆÙ„ (Ù…Ø«Ø§Ù„: BTC)
ğŸ“Š `/chart <Ø±Ù…Ø²>` - Ø¹Ø±Ø¶ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ Ù„Ø²ÙˆØ¬ ØªØ¯Ø§ÙˆÙ„
ğŸ› ï¸ `/admin` - Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù† (Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·)
âœ… `/running` Ø£Ùˆ 'Ø­Ø§Ù„Ø©' - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª

ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ø£Ùˆ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ù„ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ø¨Ø¯Ù„ `/help`)
ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ ÙƒØªØ§Ø¨Ø© Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© (Ù…Ø«Ù„ BTC Ø£Ùˆ ETH) Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±""",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©: {e}")
            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

    async def price(self, update: Update, context):
        """Ø£Ù…Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø±"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['price'] += 1

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
            if not context.args:
                await update.message.reply_text(
                    "âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ø§Ù„: /price BTC Ø£Ùˆ /price BTC/USDT).",
                    parse_mode='Markdown'
                )
                return

            symbol_input = ' '.join(context.args)
            await self._get_price_and_reply(update, context, symbol_input)

        except Exception as e:
            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ø³Ø¹Ø±: {e}"
            logger.error(error_msg) # TelegramErrorHandler will pick this up
            await update.message.reply_text(
                'âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.',
                parse_mode='Markdown'
            )

    async def search(self, update: Update, context):
        """Ø£Ù…Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© ÙˆØ§Ù„Ù„Ø§Ù…Ø±ÙƒØ²ÙŠØ©"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['search'] += 1

            if not context.args:
                await update.message.reply_text('âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø²Ù‹Ø§ Ù„Ù„Ø¨Ø­Ø« (Ù…Ø«Ø§Ù„: /search BTC)')
                return

            search_term = context.args[0].upper()
            response = f"ğŸ” **Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† {search_term}**:\n\n"
            found_results = False

            # CEX Search Logic
            cex_results = []
            if not self.exchange:
                if not await self.init_exchange():
                    logger.warning("ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ© Ù„Ù„Ø¨Ø­Ø« ÙÙŠ CEX. Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ DEX ÙÙ‚Ø·.")

            if self.exchange: # Proceed if exchange is initialized
                try:
                    markets = await self.exchange.load_markets()
                    for market_symbol, market_data in markets.items():
                        if market_data.get('base', '').upper() == search_term:
                            cex_results.append(market_data['symbol'])

                    if cex_results:
                        cex_results.sort() # Sort for consistent order
                        response += "**Ù…Ù†ØµØ§Øª Ù…Ø±ÙƒØ²ÙŠØ© (CEX - MEXC):**\n"
                        for i, symbol in enumerate(cex_results[:10]): # Show up to 10 CEX results
                            response += f"{i+1}. `{symbol}`\n"
                        response += "\n"
                        found_results = True
                except Exception as e:
                    logger.error(f"Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø£Ø³ÙˆØ§Ù‚ CEX Ø¹Ù† {search_term}: {e}")
                    # Do not send a message to user here, proceed to DEX search

            # DEX Search Logic
            dex_pairs = None
            try:
                dex_pairs = await self.fetch_dex_price(search_term) # fetch_dex_price uses search_term as base
                if dex_pairs:
                    response += "**Ù…Ù†ØµØ§Øª Ù„Ø§Ù…Ø±ÙƒØ²ÙŠØ© (DEX):**\n"
                    for i, pair in enumerate(dex_pairs[:5]):  # Show up to 5 DEX results
                        response += f"{i+1}. `{pair['price']:.6f}` USD ({pair['dex']}) - Liquidity: ${pair['liquidity']:,.0f}\n"
                    response += "\n"
                    found_results = True
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ DEX Ø¹Ù† {search_term}: {e}")
                # Do not send a message to user here if CEX might have results or if other errors occur

            if not found_results:
                response += "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø«."

            await update.message.reply_text(response, parse_mode='Markdown')

        except Exception as e:
            # Catch-all for unexpected errors during the command execution
            logger.error(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† {search_term}: {e}", exc_info=True)
            await update.message.reply_text('âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.')

    async def chart(self, update: Update, context):
        """Ø£Ù…Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['chart'] += 1
            user_id = str(update.effective_user.id)
            current_theme = self.user_chart_themes.get(user_id, 'light')

            symbol_input = context.args[0] if context.args else 'BTC'
            parsed_symbol = self._parse_symbol(symbol_input)
            initial_timeframe = '15m' # Default timeframe for initial chart

            df = await self.fetch_ohlcv(parsed_symbol, initial_timeframe)
            if df is None:
                await update.message.reply_text(
                    f"âš ï¸ Could not fetch data for {parsed_symbol}. Please try again.",
                    parse_mode='Markdown'
                )
                return

            # Apply theme for plotting
            if current_theme == 'dark':
                plt.style.use('dark_background')
                line_color, grid_alpha, edge_color = 'cyan', 0.4, 'white'
            else:
                plt.style.use('default') # Or 'seaborn-v0_8-whitegrid'
                line_color, grid_alpha, edge_color = '#2E86AB', 0.3, 'black'

            plt.figure(figsize=(12, 6))
            quote_currency = parsed_symbol.split('/')[1] if '/' in parsed_symbol else 'USDT'
            plt.plot(df['timestamp'], df['close'], label='Price', linewidth=2, color=line_color)

            title_color = edge_color if current_theme == 'dark' else 'black'
            plt.title(f'{parsed_symbol} - Chart ({initial_timeframe})', fontsize=16, fontweight='bold', color=title_color)
            plt.xlabel('Time', color=title_color)
            plt.ylabel(f'Price ({quote_currency})', color=title_color)
            plt.tick_params(axis='x', colors=edge_color)
            plt.tick_params(axis='y', colors=edge_color)

            legend = plt.legend()
            for text in legend.get_texts():
                text.set_color(edge_color)
            plt.grid(True, alpha=grid_alpha)
            plt.tight_layout()

            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
            buf.seek(0)
            plt.close('all')

            keyboard_tf = [
                [
                    InlineKeyboardButton("1m", callback_data=f"charttf_{parsed_symbol}_1m"),
                    InlineKeyboardButton("5m", callback_data=f"charttf_{parsed_symbol}_5m"),
                    InlineKeyboardButton("15m", callback_data=f"charttf_{parsed_symbol}_15m")
                ],
                [
                    InlineKeyboardButton("1h", callback_data=f"charttf_{parsed_symbol}_1h"),
                    InlineKeyboardButton("4h", callback_data=f"charttf_{parsed_symbol}_4h"),
                    InlineKeyboardButton("1d", callback_data=f"charttf_{parsed_symbol}_1d")
                ]
            ]
            theme_button_text = "ğŸŒ™ Dark Mode" if current_theme == 'light' else "â˜€ï¸ Light Mode"
            next_theme = 'dark' if current_theme == 'light' else 'light'
            theme_callback_data = f"charttheme_{parsed_symbol}_{initial_timeframe}_{next_theme}"
            keyboard_theme_row = [InlineKeyboardButton(theme_button_text, callback_data=theme_callback_data)]

            reply_markup = InlineKeyboardMarkup(keyboard_tf + [keyboard_theme_row])
            caption = f"ğŸ“Š **Chart for {parsed_symbol} ({initial_timeframe})**\nTheme: {current_theme.capitalize()}\nSelect timeframe or mode:"

            await update.message.reply_photo(
                photo=buf,
                caption=caption,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

        except Exception as e:
            logger.error(f"Error in /chart command for {parsed_symbol}: {e}", exc_info=True)
            await update.message.reply_text("âš ï¸ An error occurred while generating the chart.")

    async def handle_chart_callback(self, update: Update, context):
        """Handles callbacks for chart timeframe and theme changes."""
        try:
            query = update.callback_query
            await query.answer()
            user_id = str(query.from_user.id)

            data = query.data.split('_')
            callback_type = data[0]
            symbol = data[1]

            current_timeframe = data[2] # This is the timeframe of the chart WHEN THE BUTTON WAS PRESSED
            new_theme_for_button_cycle = None

            if callback_type == 'charttheme':
                new_theme = data[3]
                self.user_chart_themes[user_id] = new_theme
                current_theme_for_plot = new_theme
                # Timeframe remains the same as the current chart
                timeframe_for_plot = current_timeframe
                new_theme_for_button_cycle = 'dark' if new_theme == 'light' else 'light'

            elif callback_type == 'charttf':
                new_timeframe = data[2] # For charttf, the third element is the new timeframe
                timeframe_for_plot = new_timeframe
                current_theme_for_plot = self.user_chart_themes.get(user_id, 'light')
                new_theme_for_button_cycle = 'dark' if current_theme_for_plot == 'light' else 'light'
                current_timeframe = new_timeframe # Update current_timeframe for the caption and next theme button
            else:
                logger.warning(f"Unknown chart callback type: {query.data}")
                return

            df = await self.fetch_ohlcv(symbol, timeframe_for_plot)
            if df is None:
                await query.edit_message_text( # Use edit_message_text for error if media can't be updated
                    f"âš ï¸ Could not fetch data for {symbol} ({timeframe_for_plot}). Please try again."
                )
                return

            # Apply theme for plotting
            if current_theme_for_plot == 'dark':
                plt.style.use('dark_background')
                line_color, grid_alpha, edge_color = 'cyan', 0.4, 'white'
            else:
                plt.style.use('default')
                line_color, grid_alpha, edge_color = '#2E86AB', 0.3, 'black'

            plt.figure(figsize=(12, 6))
            quote_currency = symbol.split('/')[1] if '/' in symbol else 'USDT'
            plt.plot(df['timestamp'], df['close'], label='Price', linewidth=2, color=line_color)

            title_color = edge_color if current_theme_for_plot == 'dark' else 'black'
            plt.title(f'{symbol} - Chart ({timeframe_for_plot})', fontsize=16, fontweight='bold', color=title_color)
            plt.xlabel('Time', color=title_color)
            plt.ylabel(f'Price ({quote_currency})', color=title_color)
            plt.tick_params(axis='x', colors=edge_color)
            plt.tick_params(axis='y', colors=edge_color)

            legend = plt.legend()
            for text in legend.get_texts():
                text.set_color(edge_color)
            plt.grid(True, alpha=grid_alpha)
            plt.tight_layout()

            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
            buf.seek(0)
            plt.close('all')

            keyboard_tf_rows = [
                [
                    InlineKeyboardButton("1m", callback_data=f"charttf_{symbol}_1m"),
                    InlineKeyboardButton("5m", callback_data=f"charttf_{symbol}_5m"),
                    InlineKeyboardButton("15m", callback_data=f"charttf_{symbol}_15m")
                ],
                [
                    InlineKeyboardButton("1h", callback_data=f"charttf_{symbol}_1h"),
                    InlineKeyboardButton("4h", callback_data=f"charttf_{symbol}_4h"),
                    InlineKeyboardButton("1d", callback_data=f"charttf_{symbol}_1d")
                ]
            ]
            theme_button_text = "ğŸŒ™ Dark Mode" if current_theme_for_plot == 'light' else "â˜€ï¸ Light Mode"
            # The theme button should always use the currently displayed timeframe (timeframe_for_plot)
            theme_callback_data = f"charttheme_{symbol}_{timeframe_for_plot}_{new_theme_for_button_cycle}"
            keyboard_theme_row = [InlineKeyboardButton(theme_button_text, callback_data=theme_callback_data)]

            reply_markup = InlineKeyboardMarkup(keyboard_tf_rows + [keyboard_theme_row])

            caption = f"ğŸ“Š **Chart for {symbol} ({timeframe_for_plot})**\nTheme: {current_theme_for_plot.capitalize()}\nSelect timeframe or mode:"

            await query.message.edit_media(
                media=InputMediaPhoto(buf),
                reply_markup=reply_markup
            )
            # Edit caption separately if needed, though edit_media can take caption
            await query.message.edit_caption(caption=caption, parse_mode='Markdown', reply_markup=reply_markup)

        except Exception as e:
            logger.error(f"Error handling chart callback: {e}", exc_info=True)
            # Try to edit the message text if media editing fails or as a fallback
            try:
                await query.edit_message_text("âš ï¸ An error occurred while updating the chart.")
            except:
                pass # If editing text also fails, nothing more to do

    async def running(self, update: Update, context):
        """Ø£Ù…Ø± ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª"""
        try:
            if not await self.check_access(update):
                return

            self.command_usage['running'] += 1

            health_status = await self.health_check_system()
            status_emoji = "ğŸŸ¢" if health_status == "healthy" else "ğŸŸ¡" if health_status == "degraded" else "ğŸ”´"

            await update.message.reply_text(
                f"{status_emoji} **Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„!** ğŸš€\n"
                f"ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø©: {health_status}\n"
                f"ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%I:%M %p')}\n"
                f"ğŸ“ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©: {self.admin_settings.get('active_group_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©')}",
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: {e}")

    def _format_price(self, price: float) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø³Ø¹Ø± Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨"""
        if price < 0.000001:
            return f"{price:.10f}"
        elif price < 0.01:
            return f"{price:.8f}"
        elif price < 1:
            return f"{price:.6f}"
        elif price < 100:
            return f"{price:.4f}"
        elif price < 1000:
            return f"{price:.2f}"
        else:
            return f"{price:,.2f}"

    def _parse_amount_and_symbol(self, text: str) -> Optional[Tuple[float, str]]:
        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆØ§Ù„Ø±Ù…Ø²"""
        try:
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª
            parts = text.strip().lower().split()
            if len(parts) != 2:
                return None

            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ©
            amount = float(parts[0])
            if amount <= 0:
                return None

            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²
            symbol = parts[1].upper()
            return amount, symbol

        except (ValueError, IndexError):
            return None

    async def _calculate_value(self, amount: float, symbol: str) -> Optional[Dict]:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ"""
        try:
            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²
            parsed_symbol = self._parse_symbol(symbol)

            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± ÙÙŠ CEX
            cex_price = await self.fetch_current_price(parsed_symbol)
            if cex_price:
                return {
                    'platform': 'CEX',
                    'price': cex_price['last'],
                    'total': amount * cex_price['last']
                }

            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± ÙÙŠ DEX
            dex_prices = await self.fetch_dex_price(parsed_symbol)
            if dex_prices and len(dex_prices) > 0:
                best_price = max(dex_prices, key=lambda x: x['price'])
                return {
                    'platform': 'DEX',
                    'price': best_price['price'],
                    'total': amount * best_price['price']
                }

            return None
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø©: {e}")
            return None

    async def handle_text(self, update: Update, context):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""
        try:
            if not update or not update.message:
                return

            if not await self.check_access(update):
                return

            text = update.message.text
            if not text:
                return

            text = text.strip()

            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆØ§Ù„Ø±Ù…Ø² (Ù…Ø«Ù„ "2 btc")
            amount_symbol = self._parse_amount_and_symbol(text)
            if amount_symbol:
                amount, symbol = amount_symbol
                result = await self._calculate_value(amount, symbol)
                if result:
                    message = (
                        f"ğŸ’° **{amount} {symbol}**:\n"
                        f"ğŸ’µ `${self._format_price(result['total'])} USD`\n"
                        f"ğŸ“Š Ø§Ù„Ø³Ø¹Ø±: `${self._format_price(result['price'])}`\n"
                        f"ğŸ¦ Ø§Ù„Ù…Ù†ØµØ©: {result['platform']}\n"
                    )
                    await update.message.reply_text(message, parse_mode='Markdown')
                    return

            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
            if text.startswith("Ø³Ø¹Ø± "):
                self.command_usage['price_text'] += 1
                symbol_input = text[4:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø³Ø¹Ø± "
                await self._get_price_and_reply(update, context, symbol_input)
                return

            elif text.startswith("Ø¨Ø­Ø« "):
                self.command_usage['search_text'] += 1
                search_term = text[4:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø¨Ø­Ø« "
                context.args = [search_term] if search_term else []
                await self.search(update, context)
                return

            elif text.startswith("Ø±Ø³Ù… "):
                self.command_usage['chart_text'] += 1
                symbol_input = text[3:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø±Ø³Ù… "
                context.args = [symbol_input] if symbol_input else []
                await self.chart(update, context)
                return

            elif text.lower() == "Ù…Ø³Ø§Ø¹Ø¯Ø©":
                await self.help(update, context)
                return

            elif text.lower() == "Ø­Ø§Ù„Ø©":
                await self.running(update, context)
                return

            elif self.waiting_for_group_id and str(update.effective_user.id) == self.config['admin_id']:
                await self.handle_group_id(update, context)
                return

            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Ù…Ø«Ù„ BTC, ETH)
            if len(text.split()) == 1 and text.isalpha() and len(text) <= 10:
                await self._get_price_and_reply(update, context, text)
                return

        except Exception as e:
            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ: {e}"
            logger.error(error_msg) # TelegramErrorHandler will pick this up

    async def clean_cache(self):
        """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©"""
        try:
            current_time = time.time()
            expired = [key for key, (_, timestamp) in self.cached_data.items()
                      if current_time - timestamp > 3600]

            for key in expired:
                del self.cached_data[key]

            if expired:
                event_logger.info(f"ØªÙ… ØªÙ†Ø¸ÙŠÙ {len(expired)} Ø¹Ù†ØµØ± Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©")

        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©: {e}")

    async def schedule_cache_cleanup(self):
        """Ø¬Ø¯ÙˆÙ„Ø© ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙƒÙ„ Ø³Ø§Ø¹Ø©"""
        while True:
            await self.clean_cache()
            await asyncio.sleep(3600)

async def error_handler(update: object, context):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…"""
    try:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ« {update}: {context.error}")

        if isinstance(update, Update) and update.effective_message:
            await update.effective_message.reply_text(
                "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© ÙˆØ³ÙŠØªÙ… Ø¥ØµÙ„Ø§Ø­Ù‡Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹."
            )
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {e}")

async def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    application = None
    bot = None

    try:
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª
        bot = TradingBot(CONFIG)
        application = Application.builder().token(CONFIG['telegram_token']).build()
        bot.application = application

        # Provider function for the TelegramErrorHandler
        def get_bot_app():
            return application

        if CONFIG.get('error_group_id'):
            telegram_error_handler = TelegramErrorHandler(get_bot_app, CONFIG['error_group_id'])
            telegram_error_handler.setLevel(logging.ERROR) # Set level for this handler
            telegram_error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')) # Use the same formatter

            logger.addHandler(telegram_error_handler)
            bot.telegram_error_handler = telegram_error_handler # Store it on the bot instance

            # Process any messages that were queued before the application was ready
            telegram_error_handler.process_pending_messages()

        # Setup for TelegramEventLogHandler
        if CONFIG.get('event_group_id'):
            telegram_event_log_handler = TelegramEventLogHandler(get_bot_app, CONFIG['event_group_id'])
            # Events are typically INFO level. The event_logger itself is set to INFO.
            telegram_event_log_handler.setLevel(logging.INFO)
            # Use the same formatter as the file handler for events, or a simpler one if desired.
            # Current event_handler format: logging.Formatter('%(asctime)s - %(message)s')
            telegram_event_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))

            event_logger.addHandler(telegram_event_log_handler)
            bot.telegram_event_log_handler = telegram_event_log_handler

            # Process any messages that were queued before the application was ready
            telegram_event_log_handler.process_pending_messages()

        # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø±
        application.add_handler(CommandHandler("start", bot.start))
        application.add_handler(CommandHandler("help", bot.help))
        application.add_handler(CommandHandler("price", bot.price))
        application.add_handler(CommandHandler("search", bot.search))
        application.add_handler(CommandHandler("chart", bot.chart))
        application.add_handler(CommandHandler("running", bot.running))
        application.add_handler(CommandHandler("admin", bot.admin_panel))
        application.add_handler(CallbackQueryHandler(bot.handle_admin_callback, pattern="^admin_"))
        application.add_handler(CallbackQueryHandler(bot.handle_chart_callback, pattern="^chart(tf|theme)_"))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_text))

        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
        application.add_error_handler(error_handler)

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
        logger.info("Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
        await bot.send_to_log_group("ğŸš€ ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­!")

        # ØªØ´ØºÙŠÙ„ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
        asyncio.create_task(bot.schedule_cache_cleanup())

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
        await application.initialize()
        await application.start()

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹
        await application.updater.start_polling()

        # Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù
        try:
            while True:
                await asyncio.sleep(1)
        except asyncio.CancelledError:
            pass

    except Exception as e:
        error_msg = f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}\n{traceback.format_exc()}"
        logger.error(error_msg) # TelegramErrorHandler will pick this up if logger is configured before this point.
                                # If main fails very early, this log might not make it to Telegram.
        # The direct call to bot.send_to_error_group is removed.
        # If the TelegramErrorHandler is successfully set up, it will handle sending this to Telegram.
    finally:
        if application:
            try:
                await application.updater.stop()
                await application.stop()
                await application.shutdown()
            except Exception as shutdown_error:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨ÙˆØª: {shutdown_error}")

def run_bot():
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    try:
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©
        sys.excepthook = lambda exc_type, exc_value, exc_traceback: logger.error(
            f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {exc_value}\n{''.join(traceback.format_tb(exc_traceback))}"
        )

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
    except Exception as e:
        error_msg = f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬: {e}\n{traceback.format_exc()}"
        logger.error(error_msg)
        print(f"Ø®Ø·Ø£ ÙØ§Ø¯Ø­: {error_msg}")

if __name__ == '__main__':
    run_bot()