import sysimport asyncioimport osimport loggingfrom logging.handlers import RotatingFileHandlerimport tracebackfrom typing import Optional, Tuple, Dict, Listimport ccxt.async_support as ccxtimport aiohttpimport pandas as pdimport numpy as npimport matplotlibmatplotlib.use('Agg')import matplotlib.pyplot as pltimport ioimport timefrom collections import defaultdictfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandlerfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkupfrom telegram.error import BadRequest, Forbiddenfrom telegram import InputMediaPhotofrom tenacity import retry, stop_after_attempt, wait_fixedimport portalockerimport tafrom sklearn.ensemble import RandomForestRegressorfrom sklearn.preprocessing import StandardScalerfrom datetime import datetime, timedeltaimport re# Configure logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# Error loggererror_handler = RotatingFileHandler('errors.log', mode='a', maxBytes=10*1024*1024, backupCount=5)error_handler.setLevel(logging.ERROR)error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))logger.addHandler(error_handler)# Event loggerevent_handler = RotatingFileHandler('events.log', mode='a', maxBytes=10*1024*1024, backupCount=5)event_handler.setLevel(logging.INFO)event_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))event_logger = logging.getLogger('events')event_logger.addHandler(event_handler)event_logger.setLevel(logging.INFO)# ConfigurationCONFIG = {    "cex_api_key": "mx0vglXmxny6WvxtD0",    "cex_secret_key": "29d65e3090e34de6a519cb1495ad1562",    "telegram_token": "7702131341:AAFGprPv4JXfZD5eKXVhTPoGkIrVfjhOKtc",    "error_group_id": "-1002813041827",    "log_group_id": "-1002766045861",    "default_symbol": "BTC/USDT",    "admin_id": "5480487713"}class RateLimiter:    def __init__(self):        self.user_requests = defaultdict(list)        self.banned_users = {}        self.MAX_REQUESTS = 30        self.WARNING_THRESHOLD = 20        self.TIME_WINDOW = 60        self.BAN_DURATION = 3600    def check_rate_limit(self, user_id: str) -> Tuple[bool, Optional[str]]:        current_time = time.time()                # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©        self.user_requests[user_id] = [            t for t in self.user_requests[user_id]             if current_time - t < self.TIME_WINDOW        ]        self.user_requests[user_id].append(current_time)                # ÙØ­Øµ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†        if user_id in self.banned_users:            ban_time = self.banned_users[user_id]            if current_time - ban_time < self.BAN_DURATION:                remaining = int(self.BAN_DURATION - (current_time - ban_time))                return False, f"ğŸš« **ØªÙ… Ø­Ø¸Ø±Ùƒ** Ù„Ù…Ø¯Ø© {remaining // 60} Ø¯Ù‚ÙŠÙ‚Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø­Ø¸Ø±."            else:                del self.banned_users[user_id]                self.user_requests[user_id].clear()                # ÙØ­Øµ Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª        if len(self.user_requests[user_id]) > self.MAX_REQUESTS:            self.banned_users[user_id] = current_time            return False, f"ğŸš« **ØªÙ… Ø­Ø¸Ø±Ùƒ** Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø­Ø¸Ø±."        elif len(self.user_requests[user_id]) > self.WARNING_THRESHOLD:            return True, f"âš ï¸ **ØªØ­Ø°ÙŠØ±**: Ø£Ù†Øª ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¨ÙˆØª Ø¨Ø³Ø±Ø¹Ø© ÙƒØ¨ÙŠØ±Ø©!\nğŸ“Œ Ù„Ùˆ Ø§Ø³ØªÙ…Ø± Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·ØŒ Ø³ÙŠØªÙ… Ø­Ø¸Ø±Ùƒ Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø©."                return True, Noneclass TradingBot:    def __init__(self, config: Dict[str, str]):        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØª"""        self.config = config        self.exchange = None        self.application = None        self.cached_data = {}        self.waiting_for_group_id = False        self.command_usage = defaultdict(int)        self.rate_limiter = RateLimiter()        self.last_cache_cleanup = time.time()                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©        self.admin_settings = {            'private_enabled': True,            'active_group_id': self.config.get('default_group_id', ''),            'active_group_name': 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©'        }                # ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©        self.features = [            'RSI_14', 'RSI_7', 'RSI_21', 'MACD', 'MACD_signal', 'Bollinger_width',            'ATR_14', 'ATR_7', 'Stochastic', 'Volume_MA_20', 'Volume_MA_50',            'MA_5', 'MA_10', 'MA_20', 'MA_50', 'MA_200', 'EMA_12', 'EMA_26', 'EMA_50'        ]                # ØªØ¹Ø±ÙŠÙ Ù…Ø¯Ø¯ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ø²Ù…Ù†ÙŠØ©        self.timeframe_durations = {            '1m': timedelta(minutes=1),            '5m': timedelta(minutes=5),            '15m': timedelta(minutes=15),            '30m': timedelta(minutes=30),            '1h': timedelta(hours=1),            '4h': timedelta(hours=4),            '1d': timedelta(days=1),            '1w': timedelta(weeks=1)        }                self.health_check = {            'last_check': time.time(),            'status': 'healthy',            'errors': []        }                self.fallback_config = {            'use_cache': True,            'retry_attempts': 3,            'timeout': 30,            'max_errors': 5        }    async def health_check_system(self):        """ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø¨ÙˆØª"""        try:            current_time = time.time()            if current_time - self.health_check['last_check'] < 300:  # ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚                return self.health_check['status']            # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©            if not self.exchange:                if not await self.init_exchange():                    self.health_check['status'] = 'degraded'                    self.health_check['errors'].append('ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…Ù†ØµØ©')                    return 'degraded'            # ÙØ­Øµ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…            if self.application:                try:                    await self.application.bot.get_me()                except Exception as e:                    self.health_check['status'] = 'degraded'                    self.health_check['errors'].append(f'ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…: {e}')                    return 'degraded'            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©            self.health_check['last_check'] = current_time            self.health_check['status'] = 'healthy'            self.health_check['errors'] = []            return 'healthy'        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„ØµØ­Ø©: {e}")            self.health_check['status'] = 'degraded'            self.health_check['errors'].append(str(e))            return 'degraded'    async def init_exchange(self) -> bool:        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ© Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø§Ø³ØªØ¹Ø§Ø¯Ø©"""        try:            if self.exchange:                try:                    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ                    await self.exchange.fetch_status()                    return True                except:                    # Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ØŒ Ø£Ø¹Ø¯ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©                    self.exchange = None            # Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ©            self.exchange = ccxt.mexc({                'enableRateLimit': True,                'timeout': self.fallback_config['timeout'] * 1000,                'sandbox': False            })            # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„            await self.exchange.load_markets()            logger.info("ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ© Ø¨Ù†Ø¬Ø§Ø­")            return True        except Exception as e:            logger.error(f"ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù†ØµØ©: {e}")            self.exchange = None            return False    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1m', limit: int = 500) -> Optional[pd.DataFrame]:        """Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª OHLCV Ù…Ø¹ Ø¢Ù„ÙŠØ© Ø§Ø³ØªØ¹Ø§Ø¯Ø©"""        try:            # ÙØ­Øµ Ø§Ù„ØµØ­Ø©            if await self.health_check_system() == 'degraded':                logger.warning(f"Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ù…ØªØ¯Ù‡ÙˆØ±Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù€ {symbol}")                return self._get_cached_data(symbol, timeframe)            if not self.exchange:                if not await self.init_exchange():                    return self._get_cached_data(symbol, timeframe)            # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª            async with asyncio.timeout(self.fallback_config['timeout']):                ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)                if not ohlcv:                    return self._get_cached_data(symbol, timeframe)            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')            # Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©            self._cache_data(symbol, timeframe, df)            return df        except asyncio.TimeoutError:            logger.warning(f"Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª {symbol}")            return self._get_cached_data(symbol, timeframe)        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª {symbol}: {e}")            return self._get_cached_data(symbol, timeframe)    def _get_cached_data(self, symbol: str, timeframe: str) -> Optional[pd.DataFrame]:        """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© Ù…Ø¤Ù‚ØªØ§Ù‹"""        cache_key = f"{symbol}:{timeframe}"        if cache_key in self.cached_data:            cached, timestamp = self.cached_data[cache_key]            if (time.time() - timestamp) < 300:  # 5 Ø¯Ù‚Ø§Ø¦Ù‚                return cached        return None    def _cache_data(self, symbol: str, timeframe: str, df: pd.DataFrame):        """ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¤Ù‚ØªØ§Ù‹"""        cache_key = f"{symbol}:{timeframe}"        self.cached_data[cache_key] = (df, time.time())    def _parse_symbol(self, input_symbol: str) -> str:        """ØªØ­Ù„ÙŠÙ„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©"""        try:            if not input_symbol or not isinstance(input_symbol, str):                return self.config['default_symbol']                        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±Ù…Ø²            symbol = input_symbol.strip().upper()                        if not symbol:                return self.config['default_symbol']                        # Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /            if '/' in symbol:                parts = symbol.split('/')                if len(parts) == 2 and parts[0] and parts[1]:                    return symbol                else:                    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ­ÙŠØ­                    base = parts[0] if parts[0] else 'BTC'                    return f"{base}/USDT"            else:                # Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /ØŒ Ø£Ø¶Ù USDT Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹                return f"{symbol}/USDT"                        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø©: {e}")            return self.config['default_symbol']    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_current_price(self, symbol: str) -> Optional[Dict]:        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø¹Ù…Ù„Ø©"""        try:            if not symbol or not isinstance(symbol, str):                logger.error(f"Ø±Ù…Ø² Ø¹Ù…Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­: {symbol}")                return None            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø² Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­ØªÙ‡            parsed_symbol = self._parse_symbol(symbol)                        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø²            if len(parsed_symbol.split('/')) != 2:                logger.error(f"ØªÙ†Ø³ÙŠÙ‚ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­: {symbol}")                return None            if not self.exchange:                if not await self.init_exchange():                    return None            ticker = await self.exchange.fetch_ticker(parsed_symbol)            if not ticker or 'last' not in ticker:                logger.error(f"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {parsed_symbol}")                return None            return {                'last': float(ticker['last']),                'percentage': float(ticker.get('percentage', 0)),                'high': float(ticker.get('high', 0)),                'low': float(ticker.get('low', 0)),                'volume': float(ticker.get('baseVolume', 0)),                'symbol': parsed_symbol            }                    except ccxt.NetworkError as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")            return None        except ccxt.ExchangeError as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙˆØ±ØµØ© Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")            return None        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {symbol}: {e}")            return None    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_dex_price(self, symbol: str) -> Optional[List[Dict]]:        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù…Ù† Ù…Ù†ØµØ§Øª DEX"""        try:            async with asyncio.timeout(10):                # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø² Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†                if '/' in symbol:                    base, quote = symbol.split('/', 1)  # Ø§Ø³ØªØ®Ø¯Ø§Ù… maxsplit=1                else:                    # Ø¥Ø°Ø§ Ù„Ù… ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ /, Ø§ÙØªØ±Ø¶ USDT ÙƒØ¹Ù…Ù„Ø© Ù…Ù‚Ø§Ø¨Ù„Ø©                    base = symbol                    quote = 'USDT'                                url = f"https://api.dexscreener.com/latest/dex/search?q={base}"                async with aiohttp.ClientSession() as session:                    async with session.get(url, timeout=10) as response:                        response.raise_for_status()                        data = await response.json()                pairs = []                for pair in data.get('pairs', []):                    if pair.get('quoteToken', {}).get('symbol', '').upper() == quote.upper():                        pairs.append({                            'price': float(pair.get('priceUsd', 0)),                            'dex': pair.get('dexId', 'Unknown'),                            'liquidity': float(pair.get('liquidity', {}).get('usd', 0)),                            'volume': float(pair.get('volume', {}).get('h24', 0)),                            'change_24h': float(pair.get('priceChange', {}).get('h24', 0))                        })                return pairs if pairs else None        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø³Ø¹Ø± {symbol} Ù…Ù† DEX: {e}"            logger.error(error_msg)            if self.application:                asyncio.create_task(self.send_to_error_group(error_msg))            return None    async def send_to_log_group(self, message: str):        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª"""        try:            if self.application and self.config.get('log_group_id'):                await self.application.bot.send_message(                    chat_id=self.config['log_group_id'],                    text=message,                    parse_mode='Markdown'                )        except (BadRequest, Forbidden) as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø³Ø¬Ù„ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª: {e}")    async def send_to_error_group(self, message: str):        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""        try:            if not self.application or not self.config.get('error_group_id'):                return            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø®Ø§ØµØ©            clean_message = message.replace('`', '').replace('*', '').replace('_', '')            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹            max_length = 4000            if len(clean_message) > max_length:                parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]                for part in parts:                    await self.application.bot.send_message(                        chat_id=self.config['error_group_id'],                        text=f"âš ï¸ **Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n```\n{part}\n```",                        parse_mode='Markdown'                    )            else:                await self.application.bot.send_message(                    chat_id=self.config['error_group_id'],                    text=f"âš ï¸ **Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…**\n```\n{clean_message}\n```",                    parse_mode='Markdown'                )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø®Ø·Ø£ Ø¥Ù„Ù‰ Ø¬Ø±ÙˆØ¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {e}")    async def check_access(self, update: Update) -> bool:        """ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""        try:            user_id = str(update.effective_user.id)            chat_id = str(update.effective_chat.id)            is_private = update.effective_chat.type == 'private'            is_admin = user_id == self.config['admin_id']            if is_admin:                return True            # ÙØ­Øµ Ø­Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª            allowed, message = self.rate_limiter.check_rate_limit(user_id)            if not allowed:                await update.message.reply_text(message, parse_mode='Markdown')                if "ØªÙ… Ø­Ø¸Ø±Ùƒ" in message:                    await self.send_to_error_group(                        f"ğŸš« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {update.effective_user.first_name} (ID: {user_id}) ØªÙ… Ø­Ø¸Ø±Ù‡ Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØ±Ø·."                    )                return False            # ÙØ­Øµ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©            if is_private and not self.admin_settings['private_enabled']:                await update.message.reply_text(                    "âš ï¸ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù‚ÙÙ„Øª Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ© Ø­Ø§Ù„ÙŠÙ‹Ø§.\nğŸ“Œ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§ Ø£Ùˆ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø£Ø¯Ù…Ù†.",                    parse_mode='Markdown'                )                return False            # ÙØ­Øµ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©            if not is_private and self.admin_settings.get('active_group_id') and chat_id != self.admin_settings['active_group_id']:                return False            # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯Øª            if message:                await update.message.reply_text(message, parse_mode='Markdown')            return True        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©: {e}")            return False    async def admin_panel(self, update: Update, context):        """Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†"""        try:            if str(update.effective_user.id) != self.config['admin_id']:                await update.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·!", parse_mode='Markdown')                return            keyboard = [                [                    InlineKeyboardButton(                        f"{'Ø¥ÙŠÙ‚Ø§Ù' if self.admin_settings['private_enabled'] else 'ØªÙØ¹ÙŠÙ„'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©",                        callback_data='admin_toggle_private'                    )                ],                [                    InlineKeyboardButton("ØªØ¹ÙŠÙŠÙ† Ù…Ø¬Ù…ÙˆØ¹Ø©", callback_data='admin_set_group')                ],                [                    InlineKeyboardButton("Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª", callback_data='admin_restart_bot'),                    InlineKeyboardButton("Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…", callback_data='admin_usage_stats')                ],                [                    InlineKeyboardButton("Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù„ÙˆØ­Ø©", callback_data='admin_close_panel')                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            status_msg = (                f"ğŸ› ï¸ **Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†** ğŸ› ï¸\n\n"                f"ğŸ“± Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©: {'Ù…ÙØ¹Ù„Ø©' if self.admin_settings['private_enabled'] else 'Ù…Ù‚ÙÙ„Ø©'}\n"                f"ğŸ‘¥ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©: {self.admin_settings['active_group_name']}\n"                f"âš¡ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: {await self.health_check_system()}\n\n"                f"Ø§Ø®ØªØ± Ø¥Ø¹Ø¯Ø§Ø¯Ù‹Ø§ Ù„ØªØ®ØµÙŠØµÙ‡:"            )            await update.message.reply_text(                status_msg,                reply_markup=reply_markup,                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†: {e}")            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ….")    async def handle_admin_callback(self, update: Update, context):        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù†"""        try:            query = update.callback_query            await query.answer()            if str(query.from_user.id) != self.config['admin_id']:                await query.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·!", parse_mode='Markdown')                return            data = query.data            if data == 'admin_toggle_private':                self.admin_settings['private_enabled'] = not self.admin_settings['private_enabled']                status = "Ù…ÙØ¹Ù„Ø©" if self.admin_settings['private_enabled'] else "Ù…Ù‚ÙÙ„Ø©"                await query.message.edit_text(                    f"âœ… ØªÙ… {'ØªÙØ¹ÙŠÙ„' if self.admin_settings['private_enabled'] else 'Ø¥ÙŠÙ‚Ø§Ù'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©.\nØ§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {status}",                    parse_mode='Markdown'                )                await self.send_to_log_group(f"ØªÙ… {'ØªÙØ¹ÙŠÙ„' if self.admin_settings['private_enabled'] else 'Ø¥ÙŠÙ‚Ø§Ù'} Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ© Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¯Ù…Ù†.")            elif data == 'admin_set_group':                self.waiting_for_group_id = True                await query.message.edit_text(                    "ğŸ“Œ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø±Ø³Ù„ ID Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© (Ù…Ø«Ø§Ù„: -1001234567890) Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠÙ‡Ø§.",                    parse_mode='Markdown'                )            elif data == 'admin_restart_bot':                await query.message.edit_text("ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...", parse_mode='Markdown')                await self.send_to_log_group("ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¯Ù…Ù†.")                os._exit(0)            elif data == 'admin_usage_stats':                stats = "\n".join([f"{cmd}: {count} Ù…Ø±Ø©" for cmd, count in self.command_usage.items()])                await query.message.edit_text(                    f"ğŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…**:\n{stats if stats else 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø¹Ø¯.'}",                    parse_mode='Markdown'                )            elif data == 'admin_close_panel':                await query.message.delete()        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø¯Ù…Ù†: {e}")    async def handle_group_id(self, update: Update, context):        """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹ÙŠÙŠÙ† ID Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©"""        try:            if not self.waiting_for_group_id or str(update.effective_user.id) != self.config['admin_id']:                return            group_id = update.message.text.strip()            chat = await context.bot.get_chat(group_id)                        self.admin_settings['active_group_id'] = group_id            self.admin_settings['active_group_name'] = chat.title            self.waiting_for_group_id = False            await update.message.reply_text(                f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© **{chat.title}** (ID: {group_id}) Ø¨Ù†Ø¬Ø§Ø­!",                parse_mode='Markdown'            )            await context.bot.send_message(                chat_id=group_id,                text=(                    f"ğŸ‰ **ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© {chat.title}** Ø¨ÙˆØ§Ø³Ø·Ø© {update.effective_user.first_name}! ğŸš€\n"                    "ğŸ“‹ Ø§Ø³ØªØ®Ø¯Ù… `/help` Ø£Ùˆ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©.\n"                    "ğŸ’¡ Ø¬Ø§Ù‡Ø² Ù„Ø®Ø¯Ù…ØªÙƒÙ… ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ÙˆØ§Ù„ØªØ¯Ø§ÙˆÙ„!"                ),                parse_mode='Markdown'            )            await self.send_to_log_group(f"ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {chat.title} (ID: {group_id}) Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø¯Ù…Ù†.")        except Exception as e:            await update.message.reply_text(                f"âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ ID ØµØ­ÙŠØ­ ÙˆØ£Ù† Ø§Ù„Ø¨ÙˆØª Ø¹Ø¶Ùˆ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.",                parse_mode='Markdown'            )            await self.send_to_error_group(f"Ø®Ø·Ø£ ÙÙŠ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {group_id}: {e}")    async def _get_price_and_reply(self, update: Update, context, requested_arg: Optional[str]):        """Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± ÙˆØ§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""        try:            if not requested_arg:                await update.message.reply_text(                    "âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ø§Ù„: /price BTC Ø£Ùˆ Ø³Ø¹Ø± BTC).",                    parse_mode='Markdown'                )                return            # ØªØ­Ù„ÙŠÙ„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø©            symbol = self._parse_symbol(requested_arg)                        # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ CEX Ø£ÙˆÙ„Ø§Ù‹            ticker_data = await self.fetch_current_price(symbol)                        if ticker_data:                price = float(ticker_data['last'])                percentage_change = ticker_data.get('percentage', 0)                change_str = f" | {'+' if percentage_change >= 0 else ''}{percentage_change:.2f}%" if percentage_change else ""                                quote_display = symbol.split('/')[1]                                reply_message = (                    f"ğŸ“ˆ **{symbol} (CEX)**\n\n"                    f"ğŸ’° `{price:.8f} {quote_display.upper()}`{change_str}\n\n"                    f"ğŸ•’ {datetime.now().strftime('%I:%M:%S %p')}"                )                await update.message.reply_text(reply_message, parse_mode='Markdown')                return            # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ DEX Ø¥Ø°Ø§ Ù„Ù… ÙŠÙÙˆØ¬Ø¯ ÙÙŠ CEX            dex_pairs = await self.fetch_dex_price(symbol)                        if dex_pairs:                best_dex_pair = dex_pairs[0]                dex_price = best_dex_pair['price']                dex_name = best_dex_pair['dex']                dex_change_24h = best_dex_pair.get('change_24h', 0.0)                change_str_dex = f" | {'+' if dex_change_24h >= 0 else ''}{dex_change_24h:.2f}%"                                reply_message_dex = (                    f"ğŸ“ˆ **{symbol} ({dex_name} - DEX)**\n\n"                    f"ğŸ’° `{dex_price:.8f} USD`{change_str_dex}\n\n"                    f"ğŸ•’ {datetime.now().strftime('%I:%M:%S %p')}"                )                await update.message.reply_text(reply_message_dex, parse_mode='Markdown')                return                        # Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±            await update.message.reply_text(                f"âš ï¸ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ù„Ù€ {requested_arg}. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ù…Ø² ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",                parse_mode='Markdown'            )        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ _get_price_and_reply Ù„Ù€ {requested_arg}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text(                "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. ØªÙ… Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.",                parse_mode='Markdown'            )    # Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª    async def start(self, update: Update, context):        """Ø£Ù…Ø± Ø§Ù„Ø¨Ø¯Ø¡"""        try:            if not await self.check_access(update):                return            self.command_usage['start'] += 1            group_name = self.admin_settings.get('active_group_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©')            await update.message.reply_text(                f"ğŸ‘‹ **Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø§Ù„ØªØ¯Ø§ÙˆÙ„!** ğŸš€\n"                f"ğŸ“ˆ Ø£Ù†Ø§ Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±ØŒ ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ø³ÙˆÙ‚ØŒ ÙˆÙØ±Øµ Ø§Ù„ØªØ¯Ø§ÙˆÙ„.\n"                f"ğŸ“ Ø§Ù„Ø¨ÙˆØª Ù…ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: **{group_name}**\n"                f"ğŸ“‹ Ø§Ø³ØªØ®Ø¯Ù… `/help` Ø£Ùˆ Ø§ÙƒØªØ¨ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©.\n"                f"ğŸ’¡ Ø¬Ø§Ù‡Ø² Ù„Ø®Ø¯Ù…ØªÙƒ!",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ø¨Ø¯Ø¡: {e}")            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")    async def help(self, update: Update, context):        """Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""        try:            if not await self.check_access(update):                return            self.command_usage['help'] += 1            await update.message.reply_text(                """ğŸ“‹ **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©**:ğŸ‘‹ `/start` - Ø¨Ø¯Ø¡ Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØªğŸ’° `/price <Ø±Ù…Ø²>` - Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø²ÙˆØ¬ ØªØ¯Ø§ÙˆÙ„ (Ù…Ø«Ø§Ù„: BTC/USDT)ğŸ” `/search <Ø±Ù…Ø²>` - Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø²ÙˆØ§Ø¬ ØªØ¯Ø§ÙˆÙ„ (Ù…Ø«Ø§Ù„: BTC)ğŸ“Š `/chart <Ø±Ù…Ø²>` - Ø¹Ø±Ø¶ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ Ù„Ø²ÙˆØ¬ ØªØ¯Ø§ÙˆÙ„ğŸ› ï¸ `/admin` - Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø£Ø¯Ù…Ù† (Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·)âœ… `/running` Ø£Ùˆ 'Ø­Ø§Ù„Ø©' - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØªğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ø£Ùˆ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ù„ 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ø¨Ø¯Ù„ `/help`)ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ ÙƒØªØ§Ø¨Ø© Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© (Ù…Ø«Ù„ BTC Ø£Ùˆ ETH) Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø±""",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©: {e}")            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")    async def price(self, update: Update, context):        """Ø£Ù…Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¹Ø±"""        try:            if not await self.check_access(update):                return            self.command_usage['price'] += 1            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª            if not context.args:                await update.message.reply_text(                    "âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ø§Ù„: /price BTC Ø£Ùˆ /price BTC/USDT).",                    parse_mode='Markdown'                )                return            symbol_input = ' '.join(context.args)            await self._get_price_and_reply(update, context, symbol_input)        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø£Ù…Ø± Ø§Ù„Ø³Ø¹Ø±: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text(                'âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.',                parse_mode='Markdown'            )    async def search(self, update: Update, context):        """Ø£Ù…Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ØªØ¯Ø§ÙˆÙ„"""        try:            if not await self.check_access(update):                return            self.command_usage['search'] += 1            if not context.args:                await update.message.reply_text('âš ï¸ Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø£Ø¯Ø®Ù„ Ø±Ù…Ø²Ù‹Ø§ Ù„Ù„Ø¨Ø­Ø« (Ù…Ø«Ø§Ù„: /search BTC)')                return            search_term = context.args[0].upper()                        # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ DEX            dex_pairs = await self.fetch_dex_price(search_term)                        response = f"ğŸ” **Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† {search_term}**:\n\n"                        if dex_pairs:                response += "**Ù…Ù†ØµØ§Øª Ù„Ø§Ù…Ø±ÙƒØ²ÙŠØ© (DEX):**\n"                for i, pair in enumerate(dex_pairs[:5]):  # Ø£ÙˆÙ„ 5 Ù†ØªØ§Ø¦Ø¬                    response += f"{i+1}. `{pair['price']:.6f}` USD ({pair['dex']})\n"            else:                response += "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø«."            await update.message.reply_text(response, parse_mode='Markdown')        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† {search_term}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text('âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.')    async def chart(self, update: Update, context):        """Ø£Ù…Ø± Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ"""        try:            if not await self.check_access(update):                return            self.command_usage['chart'] += 1            symbol_input = context.args[0] if context.args else 'BTC'            symbol = self._parse_symbol(symbol_input)            df = await self.fetch_ohlcv(symbol, '15m')            if df is None:                await update.message.reply_text(                    f"âš ï¸ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ {symbol}. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",                    parse_mode='Markdown'                )                return            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ            plt.figure(figsize=(12, 6))            plt.plot(df['timestamp'], df['close'], label='Ø§Ù„Ø³Ø¹Ø±', linewidth=2, color='#2E86AB')            plt.title(f'{symbol} - Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ (15 Ø¯Ù‚ÙŠÙ‚Ø©)', fontsize=16, fontweight='bold')            plt.xlabel('Ø§Ù„ÙˆÙ‚Øª')            plt.ylabel('Ø§Ù„Ø³Ø¹Ø± (USDT)')            plt.legend()            plt.grid(True, alpha=0.3)            plt.tight_layout()            # Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ù… ÙÙŠ buffer            buf = io.BytesIO()            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')            buf.seek(0)            plt.close('all')            # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ø²Ù…Ù†ÙŠØ©            keyboard = [                [                    InlineKeyboardButton("1m", callback_data=f"chart_{symbol}_1m"),                    InlineKeyboardButton("5m", callback_data=f"chart_{symbol}_5m"),                    InlineKeyboardButton("15m", callback_data=f"chart_{symbol}_15m")                ],                [                    InlineKeyboardButton("1h", callback_data=f"chart_{symbol}_1h"),                    InlineKeyboardButton("4h", callback_data=f"chart_{symbol}_4h"),                    InlineKeyboardButton("1d", callback_data=f"chart_{symbol}_1d")                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            await update.message.reply_photo(                photo=buf,                caption=f"ğŸ“Š **Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ Ù„Ù€ {symbol} (15m)**\nØ§Ø®ØªØ± Ø¥Ø·Ø§Ø±Ù‹Ø§ Ø²Ù…Ù†ÙŠÙ‹Ø§ Ø¢Ø®Ø±:",                parse_mode='Markdown',                reply_markup=reply_markup            )        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ù„Ù€ {symbol}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ.")    async def handle_chart_callback(self, update: Update, context):        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ"""        try:            query = update.callback_query            await query.answer()            data = query.data.split('_')            if len(data) != 3 or data[0] != 'chart':                return            symbol, timeframe = data[1], data[2]            df = await self.fetch_ohlcv(symbol, timeframe)            if df is None:                await query.message.reply_text(                    f"âš ï¸ ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ {symbol} Ø¹Ù„Ù‰ {timeframe}.",                    parse_mode='Markdown'                )                return            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯            plt.figure(figsize=(12, 6))            plt.plot(df['timestamp'], df['close'], label='Ø§Ù„Ø³Ø¹Ø±', linewidth=2, color='#2E86AB')            plt.title(f'{symbol} - Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ ({timeframe})', fontsize=16, fontweight='bold')            plt.xlabel('Ø§Ù„ÙˆÙ‚Øª')            plt.ylabel('Ø§Ù„Ø³Ø¹Ø± (USDT)')            plt.legend()            plt.grid(True, alpha=0.3)            plt.tight_layout()            buf = io.BytesIO()            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')            buf.seek(0)            plt.close('all')            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù…Ø±Ø© Ø£Ø®Ø±Ù‰            keyboard = [                [                    InlineKeyboardButton("1m", callback_data=f"chart_{symbol}_1m"),                    InlineKeyboardButton("5m", callback_data=f"chart_{symbol}_5m"),                    InlineKeyboardButton("15m", callback_data=f"chart_{symbol}_15m")                ],                [                    InlineKeyboardButton("1h", callback_data=f"chart_{symbol}_1h"),                    InlineKeyboardButton("4h", callback_data=f"chart_{symbol}_4h"),                    InlineKeyboardButton("1d", callback_data=f"chart_{symbol}_1d")                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            await query.message.edit_media(                media=InputMediaPhoto(buf),                reply_markup=reply_markup            )            await query.message.edit_caption(                caption=f"ğŸ“Š **Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ Ù„Ù€ {symbol} ({timeframe})**\nØ§Ø®ØªØ± Ø¥Ø·Ø§Ø±Ù‹Ø§ Ø²Ù…Ù†ÙŠÙ‹Ø§ Ø¢Ø®Ø±:",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ: {e}")    async def running(self, update: Update, context):        """Ø£Ù…Ø± ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª"""        try:            if not await self.check_access(update):                return            self.command_usage['running'] += 1                        health_status = await self.health_check_system()            status_emoji = "ğŸŸ¢" if health_status == "healthy" else "ğŸŸ¡" if health_status == "degraded" else "ğŸ”´"            await update.message.reply_text(                f"{status_emoji} **Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„!** ğŸš€\n"                f"ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø©: {health_status}\n"                f"ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%I:%M %p')}\n"                f"ğŸ“ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù†Ø´Ø·Ø©: {self.admin_settings.get('active_group_name', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©')}",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª: {e}")    def _format_price(self, price: float) -> str:        """ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø³Ø¹Ø± Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø§Ø³Ø¨"""        if price < 0.000001:            return f"{price:.10f}"        elif price < 0.01:            return f"{price:.8f}"        elif price < 1:            return f"{price:.6f}"        elif price < 100:            return f"{price:.4f}"        elif price < 1000:            return f"{price:.2f}"        else:            return f"{price:,.2f}"    def _parse_amount_and_symbol(self, text: str) -> Optional[Tuple[float, str]]:        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆØ§Ù„Ø±Ù…Ø²"""        try:            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª            parts = text.strip().lower().split()            if len(parts) != 2:                return None            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒÙ…ÙŠØ©            amount = float(parts[0])            if amount <= 0:                return None            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²            symbol = parts[1].upper()            return amount, symbol        except (ValueError, IndexError):            return None    async def _calculate_value(self, amount: float, symbol: str) -> Optional[Dict]:        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø± Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠ"""        try:            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²            parsed_symbol = self._parse_symbol(symbol)                        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± ÙÙŠ CEX            cex_price = await self.fetch_current_price(parsed_symbol)            if cex_price:                return {                    'platform': 'CEX',                    'price': cex_price['last'],                    'total': amount * cex_price['last']                }            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø³Ø¹Ø± ÙÙŠ DEX            dex_prices = await self.fetch_dex_price(parsed_symbol)            if dex_prices and len(dex_prices) > 0:                best_price = max(dex_prices, key=lambda x: x['price'])                return {                    'platform': 'DEX',                    'price': best_price['price'],                    'total': amount * best_price['price']                }            return None        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø©: {e}")            return None    async def handle_text(self, update: Update, context):        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©"""        try:            if not update or not update.message:                return            if not await self.check_access(update):                return            text = update.message.text            if not text:                return            text = text.strip()            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙ…ÙŠØ© ÙˆØ§Ù„Ø±Ù…Ø² (Ù…Ø«Ù„ "2 btc")            amount_symbol = self._parse_amount_and_symbol(text)            if amount_symbol:                amount, symbol = amount_symbol                result = await self._calculate_value(amount, symbol)                if result:                    message = (                        f"ğŸ’° **{amount} {symbol}**:\n"                        f"ğŸ’µ `${self._format_price(result['total'])} USD`\n"                        f"ğŸ“Š Ø§Ù„Ø³Ø¹Ø±: `${self._format_price(result['price'])}`\n"                        f"ğŸ¦ Ø§Ù„Ù…Ù†ØµØ©: {result['platform']}\n"                    )                    await update.message.reply_text(message, parse_mode='Markdown')                    return            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©            if text.startswith("Ø³Ø¹Ø± "):                self.command_usage['price_text'] += 1                symbol_input = text[4:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø³Ø¹Ø± "                await self._get_price_and_reply(update, context, symbol_input)                return            elif text.startswith("Ø¨Ø­Ø« "):                self.command_usage['search_text'] += 1                search_term = text[4:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø¨Ø­Ø« "                context.args = [search_term] if search_term else []                await self.search(update, context)                return            elif text.startswith("Ø±Ø³Ù… "):                self.command_usage['chart_text'] += 1                symbol_input = text[3:].strip()  # Ø¥Ø²Ø§Ù„Ø© "Ø±Ø³Ù… "                context.args = [symbol_input] if symbol_input else []                await self.chart(update, context)                return            elif text.lower() == "Ù…Ø³Ø§Ø¹Ø¯Ø©":                await self.help(update, context)                return            elif text.lower() == "Ø­Ø§Ù„Ø©":                await self.running(update, context)                return            elif self.waiting_for_group_id and str(update.effective_user.id) == self.config['admin_id']:                await self.handle_group_id(update, context)                return            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Ù…Ø«Ù„ BTC, ETH)            if len(text.split()) == 1 and text.isalpha() and len(text) <= 10:                await self._get_price_and_reply(update, context, text)                return        except Exception as e:            error_msg = f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)    async def clean_cache(self):        """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©"""        try:            current_time = time.time()            expired = [key for key, (_, timestamp) in self.cached_data.items()                       if current_time - timestamp > 3600]                        for key in expired:                del self.cached_data[key]            if expired:                event_logger.info(f"ØªÙ… ØªÙ†Ø¸ÙŠÙ {len(expired)} Ø¹Ù†ØµØ± Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©")        except Exception as e:            logger.error(f"Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©: {e}")    async def schedule_cache_cleanup(self):        """Ø¬Ø¯ÙˆÙ„Ø© ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙƒÙ„ Ø³Ø§Ø¹Ø©"""        while True:            await self.clean_cache()            await asyncio.sleep(3600)async def error_handler(update: object, context):    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…"""    try:        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ« {update}: {context.error}")                if isinstance(update, Update) and update.effective_message:            await update.effective_message.reply_text(                "âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© ÙˆØ³ÙŠØªÙ… Ø¥ØµÙ„Ø§Ø­Ù‡Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹."            )    except Exception as e:        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {e}")async def main():    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""    application = None    bot = None        try:        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙˆØª        bot = TradingBot(CONFIG)        application = Application.builder().token(CONFIG['telegram_token']).build()        bot.application = application        # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø±        application.add_handler(CommandHandler("start", bot.start))        application.add_handler(CommandHandler("help", bot.help))        application.add_handler(CommandHandler("price", bot.price))        application.add_handler(CommandHandler("search", bot.search))        application.add_handler(CommandHandler("chart", bot.chart))        application.add_handler(CommandHandler("running", bot.running))        application.add_handler(CommandHandler("admin", bot.admin_panel))        application.add_handler(CallbackQueryHandler(bot.handle_admin_callback, pattern="^admin_"))        application.add_handler(CallbackQueryHandler(bot.handle_chart_callback, pattern="^chart_"))        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_text))        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡        application.add_error_handler(error_handler)        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª        logger.info("Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")        await bot.send_to_log_group("ğŸš€ ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­!")        # ØªØ´ØºÙŠÙ„ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©        asyncio.create_task(bot.schedule_cache_cleanup())        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª        await application.initialize()        await application.start()        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹        await application.updater.start_polling()        # Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù        try:            while True:                await asyncio.sleep(1)        except asyncio.CancelledError:            pass    except Exception as e:        error_msg = f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª: {e}\n{traceback.format_exc()}"        logger.error(error_msg)        if bot:            try:                await bot.send_to_error_group(error_msg)            except Exception as send_error:                logger.error(f"ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£: {send_error}")    finally:        if application:            try:                await application.updater.stop()                await application.stop()                await application.shutdown()            except Exception as shutdown_error:                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨ÙˆØª: {shutdown_error}")def run_bot():    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""    try:        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©        sys.excepthook = lambda exc_type, exc_value, exc_traceback: logger.error(            f"Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {exc_value}\n{''.join(traceback.format_tb(exc_traceback))}"        )        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª        asyncio.run(main())    except KeyboardInterrupt:        logger.info("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")    except Exception as e:        error_msg = f"Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬: {e}\n{traceback.format_exc()}"        logger.error(error_msg)        print(f"Ø®Ø·Ø£ ÙØ§Ø¯Ø­: {error_msg}")if __name__ == '__main__':    run_bot()