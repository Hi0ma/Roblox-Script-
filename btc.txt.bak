import sysimport asyncioimport osimport loggingfrom logging.handlers import RotatingFileHandlerimport tracebackfrom typing import Optional, Tuple, Dict, Listimport ccxt.async_support as ccxtimport aiohttpimport pandas as pdimport numpy as npimport matplotlibmatplotlib.use('Agg')import matplotlib.pyplot as pltimport ioimport timefrom collections import defaultdictfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandlerfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkupfrom telegram.error import BadRequest, Forbiddenfrom telegram import InputMediaPhotofrom tenacity import retry, stop_after_attempt, wait_fixedimport portalockerimport tafrom sklearn.ensemble import RandomForestRegressorfrom sklearn.preprocessing import StandardScalerfrom datetime import datetime, timedeltaimport re# Configure logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# Error loggererror_handler = RotatingFileHandler('errors.log', mode='a', maxBytes=10*1024*1024, backupCount=5)error_handler.setLevel(logging.ERROR)error_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))logger.addHandler(error_handler)# Event loggerevent_handler = RotatingFileHandler('events.log', mode='a', maxBytes=10*1024*1024, backupCount=5)event_handler.setLevel(logging.INFO)event_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))event_logger = logging.getLogger('events')event_logger.addHandler(event_handler)event_logger.setLevel(logging.INFO)# ConfigurationCONFIG = {    "cex_api_key": "mx0vglXmxny6WvxtD0",    "cex_secret_key": "29d65e3090e34de6a519cb1495ad1562",    "telegram_token": "7702131341:AAFGprPv4JXfZD5eKXVhTPoGkIrVfjhOKtc",    "error_group_id": "-1002813041827",    "log_group_id": "-1002766045861",    "default_symbol": "BTC/USDT",    "admin_id": "5480487713"}class RateLimiter:    def __init__(self):        self.user_requests = defaultdict(list)        self.banned_users = {}        self.MAX_REQUESTS = 30        self.WARNING_THRESHOLD = 20        self.TIME_WINDOW = 60        self.BAN_DURATION = 3600    def check_rate_limit(self, user_id: str) -> Tuple[bool, Optional[str]]:        current_time = time.time()                # تنظيف الطلبات القديمة        self.user_requests[user_id] = [            t for t in self.user_requests[user_id]             if current_time - t < self.TIME_WINDOW        ]        self.user_requests[user_id].append(current_time)                # فحص المستخدمين المحظورين        if user_id in self.banned_users:            ban_time = self.banned_users[user_id]            if current_time - ban_time < self.BAN_DURATION:                remaining = int(self.BAN_DURATION - (current_time - ban_time))                return False, f"🚫 **تم حظرك** لمدة {remaining // 60} دقيقة بسبب الاستخدام المفرط.\n📌 حاول مرة أخرى بعد انتهاء الحظر."            else:                del self.banned_users[user_id]                self.user_requests[user_id].clear()                # فحص حد الطلبات        if len(self.user_requests[user_id]) > self.MAX_REQUESTS:            self.banned_users[user_id] = current_time            return False, f"🚫 **تم حظرك** لمدة ساعة بسبب الاستخدام المفرط.\n📌 حاول مرة أخرى بعد انتهاء الحظر."        elif len(self.user_requests[user_id]) > self.WARNING_THRESHOLD:            return True, f"⚠️ **تحذير**: أنت تستخدم البوت بسرعة كبيرة!\n📌 لو استمر الاستخدام المفرط، سيتم حظرك لمدة ساعة."                return True, Noneclass TradingBot:    def __init__(self, config: Dict[str, str]):        """تهيئة البوت"""        self.config = config        self.exchange = None        self.application = None        self.cached_data = {}        self.waiting_for_group_id = False        self.command_usage = defaultdict(int)        self.rate_limiter = RateLimiter()        self.last_cache_cleanup = time.time()                # إضافة المتغيرات المفقودة        self.admin_settings = {            'private_enabled': True,            'active_group_id': self.config.get('default_group_id', ''),            'active_group_name': 'غير محددة'        }                # تعريف المؤشرات الفنية المطلوبة        self.features = [            'RSI_14', 'RSI_7', 'RSI_21', 'MACD', 'MACD_signal', 'Bollinger_width',            'ATR_14', 'ATR_7', 'Stochastic', 'Volume_MA_20', 'Volume_MA_50',            'MA_5', 'MA_10', 'MA_20', 'MA_50', 'MA_200', 'EMA_12', 'EMA_26', 'EMA_50'        ]                # تعريف مدد الإطارات الزمنية        self.timeframe_durations = {            '1m': timedelta(minutes=1),            '5m': timedelta(minutes=5),            '15m': timedelta(minutes=15),            '30m': timedelta(minutes=30),            '1h': timedelta(hours=1),            '4h': timedelta(hours=4),            '1d': timedelta(days=1),            '1w': timedelta(weeks=1)        }                self.health_check = {            'last_check': time.time(),            'status': 'healthy',            'errors': []        }                self.fallback_config = {            'use_cache': True,            'retry_attempts': 3,            'timeout': 30,            'max_errors': 5        }    async def health_check_system(self):        """فحص صحة البوت"""        try:            current_time = time.time()            if current_time - self.health_check['last_check'] < 300:  # كل 5 دقائق                return self.health_check['status']            # فحص الاتصال بالمنصة            if not self.exchange:                if not await self.init_exchange():                    self.health_check['status'] = 'degraded'                    self.health_check['errors'].append('فشل الاتصال بالمنصة')                    return 'degraded'            # فحص الاتصال بتيليجرام            if self.application:                try:                    await self.application.bot.get_me()                except Exception as e:                    self.health_check['status'] = 'degraded'                    self.health_check['errors'].append(f'فشل الاتصال بتيليجرام: {e}')                    return 'degraded'            # تحديث الحالة            self.health_check['last_check'] = current_time            self.health_check['status'] = 'healthy'            self.health_check['errors'] = []            return 'healthy'        except Exception as e:            logger.error(f"خطأ في فحص الصحة: {e}")            self.health_check['status'] = 'degraded'            self.health_check['errors'].append(str(e))            return 'degraded'    async def init_exchange(self) -> bool:        """تهيئة المنصة مع آلية استعادة"""        try:            if self.exchange:                try:                    # اختبار الاتصال الحالي                    await self.exchange.fetch_status()                    return True                except:                    # إذا فشل الاختبار، أعد التهيئة                    self.exchange = None            # محاولة تهيئة المنصة            self.exchange = ccxt.mexc({                'enableRateLimit': True,                'timeout': self.fallback_config['timeout'] * 1000,                'sandbox': False            })            # اختبار الاتصال            await self.exchange.load_markets()            logger.info("تم تهيئة المنصة بنجاح")            return True        except Exception as e:            logger.error(f"فشل تهيئة المنصة: {e}")            self.exchange = None            return False    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1m', limit: int = 500) -> Optional[pd.DataFrame]:        """جلب بيانات OHLCV مع آلية استعادة"""        try:            # فحص الصحة            if await self.health_check_system() == 'degraded':                logger.warning(f"حالة البوت متدهورة، استخدام البيانات المخزنة مؤقتاً لـ {symbol}")                return self._get_cached_data(symbol, timeframe)            if not self.exchange:                if not await self.init_exchange():                    return self._get_cached_data(symbol, timeframe)            # جلب البيانات            async with asyncio.timeout(self.fallback_config['timeout']):                ohlcv = await self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)                if not ohlcv:                    return self._get_cached_data(symbol, timeframe)            # معالجة البيانات            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')            # حفظ في الذاكرة المؤقتة            self._cache_data(symbol, timeframe, df)            return df        except asyncio.TimeoutError:            logger.warning(f"انتهت مهلة الاتصال في جلب بيانات {symbol}")            return self._get_cached_data(symbol, timeframe)        except Exception as e:            logger.error(f"خطأ في جلب بيانات {symbol}: {e}")            return self._get_cached_data(symbol, timeframe)    def _get_cached_data(self, symbol: str, timeframe: str) -> Optional[pd.DataFrame]:        """استرجاع البيانات المخزنة مؤقتاً"""        cache_key = f"{symbol}:{timeframe}"        if cache_key in self.cached_data:            cached, timestamp = self.cached_data[cache_key]            if (time.time() - timestamp) < 300:  # 5 دقائق                return cached        return None    def _cache_data(self, symbol: str, timeframe: str, df: pd.DataFrame):        """تخزين البيانات مؤقتاً"""        cache_key = f"{symbol}:{timeframe}"        self.cached_data[cache_key] = (df, time.time())    def _parse_symbol(self, input_symbol: str) -> str:        """تحليل رمز العملة مع معالجة الحالات المختلفة"""        try:            if not input_symbol or not isinstance(input_symbol, str):                return self.config['default_symbol']                        # تنظيف الرمز            symbol = input_symbol.strip().upper()                        if not symbol:                return self.config['default_symbol']                        # إذا كان يحتوي على /            if '/' in symbol:                parts = symbol.split('/')                if len(parts) == 2 and parts[0] and parts[1]:                    return symbol                else:                    # إذا كان التنسيق غير صحيح                    base = parts[0] if parts[0] else 'BTC'                    return f"{base}/USDT"            else:                # إذا لم يحتوي على /، أضف USDT افتراضياً                return f"{symbol}/USDT"                        except Exception as e:            logger.error(f"خطأ في تحليل رمز العملة: {e}")            return self.config['default_symbol']    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_current_price(self, symbol: str) -> Optional[Dict]:        """جلب السعر الحالي للعملة"""        try:            if not symbol or not isinstance(symbol, str):                logger.error(f"رمز عملة غير صالح: {symbol}")                return None            # تحليل الرمز للتأكد من صحته            parsed_symbol = self._parse_symbol(symbol)                        # التحقق من صحة الرمز            if len(parsed_symbol.split('/')) != 2:                logger.error(f"تنسيق رمز العملة غير صالح: {symbol}")                return None            if not self.exchange:                if not await self.init_exchange():                    return None            ticker = await self.exchange.fetch_ticker(parsed_symbol)            if not ticker or 'last' not in ticker:                logger.error(f"لم يتم العثور على بيانات السعر لـ {parsed_symbol}")                return None            return {                'last': float(ticker['last']),                'percentage': float(ticker.get('percentage', 0)),                'high': float(ticker.get('high', 0)),                'low': float(ticker.get('low', 0)),                'volume': float(ticker.get('baseVolume', 0)),                'symbol': parsed_symbol            }                    except ccxt.NetworkError as e:            logger.error(f"خطأ في الشبكة أثناء جلب السعر لـ {symbol}: {e}")            return None        except ccxt.ExchangeError as e:            logger.error(f"خطأ في البورصة أثناء جلب السعر لـ {symbol}: {e}")            return None        except Exception as e:            logger.error(f"خطأ غير متوقع أثناء جلب السعر لـ {symbol}: {e}")            return None    @retry(stop=stop_after_attempt(3), wait=wait_fixed(5))    async def fetch_dex_price(self, symbol: str) -> Optional[List[Dict]]:        """جلب السعر من منصات DEX"""        try:            async with asyncio.timeout(10):                # تحليل الرمز بشكل آمن                if '/' in symbol:                    base, quote = symbol.split('/', 1)  # استخدام maxsplit=1                else:                    # إذا لم يحتوي على /, افترض USDT كعملة مقابلة                    base = symbol                    quote = 'USDT'                                url = f"https://api.dexscreener.com/latest/dex/search?q={base}"                async with aiohttp.ClientSession() as session:                    async with session.get(url, timeout=10) as response:                        response.raise_for_status()                        data = await response.json()                pairs = []                for pair in data.get('pairs', []):                    if pair.get('quoteToken', {}).get('symbol', '').upper() == quote.upper():                        pairs.append({                            'price': float(pair.get('priceUsd', 0)),                            'dex': pair.get('dexId', 'Unknown'),                            'liquidity': float(pair.get('liquidity', {}).get('usd', 0)),                            'volume': float(pair.get('volume', {}).get('h24', 0)),                            'change_24h': float(pair.get('priceChange', {}).get('h24', 0))                        })                return pairs if pairs else None        except Exception as e:            error_msg = f"خطأ في جلب سعر {symbol} من DEX: {e}"            logger.error(error_msg)            if self.application:                asyncio.create_task(self.send_to_error_group(error_msg))            return None    async def send_to_log_group(self, message: str):        """إرسال رسالة إلى جروب السجلات"""        try:            if self.application and self.config.get('log_group_id'):                await self.application.bot.send_message(                    chat_id=self.config['log_group_id'],                    text=message,                    parse_mode='Markdown'                )        except (BadRequest, Forbidden) as e:            logger.error(f"خطأ في إرسال السجل إلى جروب السجلات: {e}")    async def send_to_error_group(self, message: str):        """إرسال رسالة خطأ إلى جروب الأخطاء"""        try:            if not self.application or not self.config.get('error_group_id'):                return            # تنظيف الرسالة من الأحرف الخاصة            clean_message = message.replace('`', '').replace('*', '').replace('_', '')            # تقسيم الرسالة إذا كانت طويلة جداً            max_length = 4000            if len(clean_message) > max_length:                parts = [clean_message[i:i+max_length] for i in range(0, len(clean_message), max_length)]                for part in parts:                    await self.application.bot.send_message(                        chat_id=self.config['error_group_id'],                        text=f"⚠️ **خطأ في النظام**\n```\n{part}\n```",                        parse_mode='Markdown'                    )            else:                await self.application.bot.send_message(                    chat_id=self.config['error_group_id'],                    text=f"⚠️ **خطأ في النظام**\n```\n{clean_message}\n```",                    parse_mode='Markdown'                )        except Exception as e:            logger.error(f"خطأ في إرسال الخطأ إلى جروب الأخطاء: {e}")    async def check_access(self, update: Update) -> bool:        """فحص صلاحية الوصول للمستخدم"""        try:            user_id = str(update.effective_user.id)            chat_id = str(update.effective_chat.id)            is_private = update.effective_chat.type == 'private'            is_admin = user_id == self.config['admin_id']            if is_admin:                return True            # فحص حد الطلبات            allowed, message = self.rate_limiter.check_rate_limit(user_id)            if not allowed:                await update.message.reply_text(message, parse_mode='Markdown')                if "تم حظرك" in message:                    await self.send_to_error_group(                        f"🚫 المستخدم {update.effective_user.first_name} (ID: {user_id}) تم حظره لمدة ساعة بسبب الاستخدام المفرط."                    )                return False            # فحص الدردشة الخاصة            if is_private and not self.admin_settings['private_enabled']:                await update.message.reply_text(                    "⚠️ الإدارة قفلت استخدام البوت في الدردشة الخاصة حاليًا.\n📌 حاول لاحقًا أو تواصل مع الأدمن.",                    parse_mode='Markdown'                )                return False            # فحص المجموعة النشطة            if not is_private and self.admin_settings.get('active_group_id') and chat_id != self.admin_settings['active_group_id']:                return False            # إرسال رسالة تحذير إذا وُجدت            if message:                await update.message.reply_text(message, parse_mode='Markdown')            return True        except Exception as e:            logger.error(f"خطأ في فحص الصلاحية: {e}")            return False    async def admin_panel(self, update: Update, context):        """لوحة تحكم الأدمن"""        try:            if str(update.effective_user.id) != self.config['admin_id']:                await update.message.reply_text("⚠️ هذا الأمر متاح للأدمن فقط!", parse_mode='Markdown')                return            keyboard = [                [                    InlineKeyboardButton(                        f"{'إيقاف' if self.admin_settings['private_enabled'] else 'تفعيل'} الدردشة الخاصة",                        callback_data='admin_toggle_private'                    )                ],                [                    InlineKeyboardButton("تعيين مجموعة", callback_data='admin_set_group')                ],                [                    InlineKeyboardButton("إعادة تشغيل البوت", callback_data='admin_restart_bot'),                    InlineKeyboardButton("إحصائيات الاستخدام", callback_data='admin_usage_stats')                ],                [                    InlineKeyboardButton("إغلاق اللوحة", callback_data='admin_close_panel')                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            status_msg = (                f"🛠️ **لوحة تحكم الأدمن** 🛠️\n\n"                f"📱 الدردشة الخاصة: {'مفعلة' if self.admin_settings['private_enabled'] else 'مقفلة'}\n"                f"👥 المجموعة النشطة: {self.admin_settings['active_group_name']}\n"                f"⚡ حالة البوت: {await self.health_check_system()}\n\n"                f"اختر إعدادًا لتخصيصه:"            )            await update.message.reply_text(                status_msg,                reply_markup=reply_markup,                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"خطأ في لوحة تحكم الأدمن: {e}")            await update.message.reply_text("⚠️ حدث خطأ في تحميل لوحة التحكم.")    async def handle_admin_callback(self, update: Update, context):        """معالجة أزرار لوحة تحكم الأدمن"""        try:            query = update.callback_query            await query.answer()            if str(query.from_user.id) != self.config['admin_id']:                await query.message.reply_text("⚠️ هذا الأمر متاح للأدمن فقط!", parse_mode='Markdown')                return            data = query.data            if data == 'admin_toggle_private':                self.admin_settings['private_enabled'] = not self.admin_settings['private_enabled']                status = "مفعلة" if self.admin_settings['private_enabled'] else "مقفلة"                await query.message.edit_text(                    f"✅ تم {'تفعيل' if self.admin_settings['private_enabled'] else 'إيقاف'} الدردشة الخاصة.\nالحالة الحالية: {status}",                    parse_mode='Markdown'                )                await self.send_to_log_group(f"تم {'تفعيل' if self.admin_settings['private_enabled'] else 'إيقاف'} الدردشة الخاصة من قبل الأدمن.")            elif data == 'admin_set_group':                self.waiting_for_group_id = True                await query.message.edit_text(                    "📌 من فضلك، أرسل ID المجموعة (مثال: -1001234567890) لتفعيل البوت فيها.",                    parse_mode='Markdown'                )            elif data == 'admin_restart_bot':                await query.message.edit_text("🔄 جاري إعادة تشغيل البوت...", parse_mode='Markdown')                await self.send_to_log_group("تم إعادة تشغيل البوت من قبل الأدمن.")                os._exit(0)            elif data == 'admin_usage_stats':                stats = "\n".join([f"{cmd}: {count} مرة" for cmd, count in self.command_usage.items()])                await query.message.edit_text(                    f"📊 **إحصائيات الاستخدام**:\n{stats if stats else 'لا توجد بيانات استخدام بعد.'}",                    parse_mode='Markdown'                )            elif data == 'admin_close_panel':                await query.message.delete()        except Exception as e:            logger.error(f"خطأ في معالجة أزرار الأدمن: {e}")    async def handle_group_id(self, update: Update, context):        """معالجة تعيين ID المجموعة"""        try:            if not self.waiting_for_group_id or str(update.effective_user.id) != self.config['admin_id']:                return            group_id = update.message.text.strip()            chat = await context.bot.get_chat(group_id)                        self.admin_settings['active_group_id'] = group_id            self.admin_settings['active_group_name'] = chat.title            self.waiting_for_group_id = False            await update.message.reply_text(                f"✅ تم تعيين المجموعة **{chat.title}** (ID: {group_id}) بنجاح!",                parse_mode='Markdown'            )            await context.bot.send_message(                chat_id=group_id,                text=(                    f"🎉 **تم تفعيل البوت في مجموعة {chat.title}** بواسطة {update.effective_user.first_name}! 🚀\n"                    "📋 استخدم `/help` أو 'مساعدة' لعرض الأوامر المتاحة.\n"                    "💡 جاهز لخدمتكم في تحليل الأسعار والتداول!"                ),                parse_mode='Markdown'            )            await self.send_to_log_group(f"تم تفعيل البوت في المجموعة {chat.title} (ID: {group_id}) من قبل الأدمن.")        except Exception as e:            await update.message.reply_text(                f"⚠️ خطأ في تعيين المجموعة. تأكد من إدخال ID صحيح وأن البوت عضو في المجموعة.",                parse_mode='Markdown'            )            await self.send_to_error_group(f"خطأ في تعيين المجموعة {group_id}: {e}")    async def _get_price_and_reply(self, update: Update, context, requested_arg: Optional[str]):        """جلب السعر والرد على المستخدم"""        try:            if not requested_arg:                await update.message.reply_text(                    "⚠️ من فضلك، أدخل رمز العملة (مثال: /price BTC أو سعر BTC).",                    parse_mode='Markdown'                )                return            # تحليل رمز العملة            symbol = self._parse_symbol(requested_arg)                        # البحث في CEX أولاً            ticker_data = await self.fetch_current_price(symbol)                        if ticker_data:                price = float(ticker_data['last'])                percentage_change = ticker_data.get('percentage', 0)                change_str = f" | {'+' if percentage_change >= 0 else ''}{percentage_change:.2f}%" if percentage_change else ""                                quote_display = symbol.split('/')[1]                                reply_message = (                    f"📈 **{symbol} (CEX)**\n\n"                    f"💰 `{price:.8f} {quote_display.upper()}`{change_str}\n\n"                    f"🕒 {datetime.now().strftime('%I:%M:%S %p')}"                )                await update.message.reply_text(reply_message, parse_mode='Markdown')                return            # البحث في DEX إذا لم يُوجد في CEX            dex_pairs = await self.fetch_dex_price(symbol)                        if dex_pairs:                best_dex_pair = dex_pairs[0]                dex_price = best_dex_pair['price']                dex_name = best_dex_pair['dex']                dex_change_24h = best_dex_pair.get('change_24h', 0.0)                change_str_dex = f" | {'+' if dex_change_24h >= 0 else ''}{dex_change_24h:.2f}%"                                reply_message_dex = (                    f"📈 **{symbol} ({dex_name} - DEX)**\n\n"                    f"💰 `{dex_price:.8f} USD`{change_str_dex}\n\n"                    f"🕒 {datetime.now().strftime('%I:%M:%S %p')}"                )                await update.message.reply_text(reply_message_dex, parse_mode='Markdown')                return                        # لم يتم العثور على السعر            await update.message.reply_text(                f"⚠️ تعذر جلب السعر لـ {requested_arg}. تأكد من الرمز وحاول مرة أخرى.",                parse_mode='Markdown'            )        except Exception as e:            error_msg = f"خطأ في _get_price_and_reply لـ {requested_arg}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text(                "⚠️ حدث خطأ أثناء معالجة طلبك. تم إبلاغ الإدارة.",                parse_mode='Markdown'            )    # أوامر البوت    async def start(self, update: Update, context):        """أمر البدء"""        try:            if not await self.check_access(update):                return            self.command_usage['start'] += 1            group_name = self.admin_settings.get('active_group_name', 'غير محددة')            await update.message.reply_text(                f"👋 **مرحبًا بك في بوت التداول!** 🚀\n"                f"📈 أنا هنا لمساعدتك في تحليل الأسعار، توقعات السوق، وفرص التداول.\n"                f"📍 البوت مفعل في المجموعة: **{group_name}**\n"                f"📋 استخدم `/help` أو اكتب 'مساعدة' لعرض الأوامر المتاحة.\n"                f"💡 جاهز لخدمتك!",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"خطأ في أمر البدء: {e}")            await update.message.reply_text("⚠️ حدث خطأ. حاول مرة أخرى.")    async def help(self, update: Update, context):        """أمر المساعدة"""        try:            if not await self.check_access(update):                return            self.command_usage['help'] += 1            await update.message.reply_text(                """📋 **قائمة الأوامر المتاحة**:👋 `/start` - بدء التفاعل مع البوت💰 `/price <رمز>` - عرض السعر الحالي لزوج تداول (مثال: BTC/USDT)🔍 `/search <رمز>` - البحث عن أزواج تداول (مثال: BTC)📊 `/chart <رمز>` - عرض رسم بياني لزوج تداول🛠️ `/admin` - لوحة تحكم الأدمن (للأدمن فقط)✅ `/running` أو 'حالة' - التحقق من حالة البوت💡 يمكنك كتابة الأوامر بالإنجليزية أو العربية (مثل 'مساعدة' بدل `/help`)💡 يمكنك كتابة رمز العملة مباشرة (مثل BTC أو ETH) للحصول على السعر""",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"خطأ في أمر المساعدة: {e}")            await update.message.reply_text("⚠️ حدث خطأ. حاول مرة أخرى.")    async def price(self, update: Update, context):        """أمر عرض السعر"""        try:            if not await self.check_access(update):                return            self.command_usage['price'] += 1            # التحقق من المدخلات            if not context.args:                await update.message.reply_text(                    "⚠️ من فضلك، أدخل رمز العملة (مثال: /price BTC أو /price BTC/USDT).",                    parse_mode='Markdown'                )                return            symbol_input = ' '.join(context.args)            await self._get_price_and_reply(update, context, symbol_input)        except Exception as e:            error_msg = f"خطأ في أمر السعر: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text(                '⚠️ حدث خطأ أثناء معالجة طلبك. حاول مرة أخرى لاحقًا.',                parse_mode='Markdown'            )    async def search(self, update: Update, context):        """أمر البحث عن أزواج التداول"""        try:            if not await self.check_access(update):                return            self.command_usage['search'] += 1            if not context.args:                await update.message.reply_text('⚠️ من فضلك، أدخل رمزًا للبحث (مثال: /search BTC)')                return            search_term = context.args[0].upper()                        # البحث في DEX            dex_pairs = await self.fetch_dex_price(search_term)                        response = f"🔍 **نتائج البحث عن {search_term}**:\n\n"                        if dex_pairs:                response += "**منصات لامركزية (DEX):**\n"                for i, pair in enumerate(dex_pairs[:5]):  # أول 5 نتائج                    response += f"{i+1}. `{pair['price']:.6f}` USD ({pair['dex']})\n"            else:                response += "❌ لم يتم العثور على نتائج للبحث."            await update.message.reply_text(response, parse_mode='Markdown')        except Exception as e:            error_msg = f"خطأ في البحث عن {search_term}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text('⚠️ حدث خطأ أثناء البحث. حاول مرة أخرى.')    async def chart(self, update: Update, context):        """أمر عرض الرسم البياني"""        try:            if not await self.check_access(update):                return            self.command_usage['chart'] += 1            symbol_input = context.args[0] if context.args else 'BTC'            symbol = self._parse_symbol(symbol_input)            df = await self.fetch_ohlcv(symbol, '15m')            if df is None:                await update.message.reply_text(                    f"⚠️ تعذر جلب البيانات لـ {symbol}. حاول مرة أخرى.",                    parse_mode='Markdown'                )                return            # إنشاء الرسم البياني            plt.figure(figsize=(12, 6))            plt.plot(df['timestamp'], df['close'], label='السعر', linewidth=2, color='#2E86AB')            plt.title(f'{symbol} - الرسم البياني (15 دقيقة)', fontsize=16, fontweight='bold')            plt.xlabel('الوقت')            plt.ylabel('السعر (USDT)')            plt.legend()            plt.grid(True, alpha=0.3)            plt.tight_layout()            # حفظ الرسم في buffer            buf = io.BytesIO()            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')            buf.seek(0)            plt.close('all')            # إنشاء أزرار للإطارات الزمنية            keyboard = [                [                    InlineKeyboardButton("1m", callback_data=f"chart_{symbol}_1m"),                    InlineKeyboardButton("5m", callback_data=f"chart_{symbol}_5m"),                    InlineKeyboardButton("15m", callback_data=f"chart_{symbol}_15m")                ],                [                    InlineKeyboardButton("1h", callback_data=f"chart_{symbol}_1h"),                    InlineKeyboardButton("4h", callback_data=f"chart_{symbol}_4h"),                    InlineKeyboardButton("1d", callback_data=f"chart_{symbol}_1d")                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            await update.message.reply_photo(                photo=buf,                caption=f"📊 **رسم بياني لـ {symbol} (15m)**\nاختر إطارًا زمنيًا آخر:",                parse_mode='Markdown',                reply_markup=reply_markup            )        except Exception as e:            error_msg = f"خطأ في عرض الرسم البياني لـ {symbol}: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)            await update.message.reply_text("⚠️ حدث خطأ في عرض الرسم البياني.")    async def handle_chart_callback(self, update: Update, context):        """معالجة أزرار الرسم البياني"""        try:            query = update.callback_query            await query.answer()            data = query.data.split('_')            if len(data) != 3 or data[0] != 'chart':                return            symbol, timeframe = data[1], data[2]            df = await self.fetch_ohlcv(symbol, timeframe)            if df is None:                await query.message.reply_text(                    f"⚠️ تعذر جلب البيانات لـ {symbol} على {timeframe}.",                    parse_mode='Markdown'                )                return            # إنشاء الرسم البياني الجديد            plt.figure(figsize=(12, 6))            plt.plot(df['timestamp'], df['close'], label='السعر', linewidth=2, color='#2E86AB')            plt.title(f'{symbol} - الرسم البياني ({timeframe})', fontsize=16, fontweight='bold')            plt.xlabel('الوقت')            plt.ylabel('السعر (USDT)')            plt.legend()            plt.grid(True, alpha=0.3)            plt.tight_layout()            buf = io.BytesIO()            plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')            buf.seek(0)            plt.close('all')            # إنشاء الأزرار مرة أخرى            keyboard = [                [                    InlineKeyboardButton("1m", callback_data=f"chart_{symbol}_1m"),                    InlineKeyboardButton("5m", callback_data=f"chart_{symbol}_5m"),                    InlineKeyboardButton("15m", callback_data=f"chart_{symbol}_15m")                ],                [                    InlineKeyboardButton("1h", callback_data=f"chart_{symbol}_1h"),                    InlineKeyboardButton("4h", callback_data=f"chart_{symbol}_4h"),                    InlineKeyboardButton("1d", callback_data=f"chart_{symbol}_1d")                ]            ]            reply_markup = InlineKeyboardMarkup(keyboard)            await query.message.edit_media(                media=InputMediaPhoto(buf),                reply_markup=reply_markup            )            await query.message.edit_caption(                caption=f"📊 **رسم بياني لـ {symbol} ({timeframe})**\nاختر إطارًا زمنيًا آخر:",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"خطأ في معالجة أزرار الرسم البياني: {e}")    async def running(self, update: Update, context):        """أمر فحص حالة البوت"""        try:            if not await self.check_access(update):                return            self.command_usage['running'] += 1                        health_status = await self.health_check_system()            status_emoji = "🟢" if health_status == "healthy" else "🟡" if health_status == "degraded" else "🔴"            await update.message.reply_text(                f"{status_emoji} **البوت يعمل!** 🚀\n"                f"📊 الحالة: {health_status}\n"                f"🕒 الوقت: {datetime.now().strftime('%I:%M %p')}\n"                f"📍 المجموعة النشطة: {self.admin_settings.get('active_group_name', 'غير محددة')}",                parse_mode='Markdown'            )        except Exception as e:            logger.error(f"خطأ في فحص حالة البوت: {e}")    def _format_price(self, price: float) -> str:        """تنسيق السعر بشكل مناسب"""        if price < 0.000001:            return f"{price:.10f}"        elif price < 0.01:            return f"{price:.8f}"        elif price < 1:            return f"{price:.6f}"        elif price < 100:            return f"{price:.4f}"        elif price < 1000:            return f"{price:.2f}"        else:            return f"{price:,.2f}"    def _parse_amount_and_symbol(self, text: str) -> Optional[Tuple[float, str]]:        """تحليل النص للحصول على الكمية والرمز"""        try:            # تقسيم النص إلى كلمات            parts = text.strip().lower().split()            if len(parts) != 2:                return None            # تحليل الكمية            amount = float(parts[0])            if amount <= 0:                return None            # تحليل الرمز            symbol = parts[1].upper()            return amount, symbol        except (ValueError, IndexError):            return None    async def _calculate_value(self, amount: float, symbol: str) -> Optional[Dict]:        """حساب القيمة بالدولار الأمريكي"""        try:            # تحليل الرمز            parsed_symbol = self._parse_symbol(symbol)                        # البحث عن السعر في CEX            cex_price = await self.fetch_current_price(parsed_symbol)            if cex_price:                return {                    'platform': 'CEX',                    'price': cex_price['last'],                    'total': amount * cex_price['last']                }            # البحث عن السعر في DEX            dex_prices = await self.fetch_dex_price(parsed_symbol)            if dex_prices and len(dex_prices) > 0:                best_price = max(dex_prices, key=lambda x: x['price'])                return {                    'platform': 'DEX',                    'price': best_price['price'],                    'total': amount * best_price['price']                }            return None        except Exception as e:            logger.error(f"خطأ في حساب القيمة: {e}")            return None    async def handle_text(self, update: Update, context):        """معالجة الرسائل النصية"""        try:            if not update or not update.message:                return            if not await self.check_access(update):                return            text = update.message.text            if not text:                return            text = text.strip()            # معالجة الكمية والرمز (مثل "2 btc")            amount_symbol = self._parse_amount_and_symbol(text)            if amount_symbol:                amount, symbol = amount_symbol                result = await self._calculate_value(amount, symbol)                if result:                    message = (                        f"💰 **{amount} {symbol}**:\n"                        f"💵 `${self._format_price(result['total'])} USD`\n"                        f"📊 السعر: `${self._format_price(result['price'])}`\n"                        f"🏦 المنصة: {result['platform']}\n"                    )                    await update.message.reply_text(message, parse_mode='Markdown')                    return            # معالجة الأوامر العربية            if text.startswith("سعر "):                self.command_usage['price_text'] += 1                symbol_input = text[4:].strip()  # إزالة "سعر "                await self._get_price_and_reply(update, context, symbol_input)                return            elif text.startswith("بحث "):                self.command_usage['search_text'] += 1                search_term = text[4:].strip()  # إزالة "بحث "                context.args = [search_term] if search_term else []                await self.search(update, context)                return            elif text.startswith("رسم "):                self.command_usage['chart_text'] += 1                symbol_input = text[3:].strip()  # إزالة "رسم "                context.args = [symbol_input] if symbol_input else []                await self.chart(update, context)                return            elif text.lower() == "مساعدة":                await self.help(update, context)                return            elif text.lower() == "حالة":                await self.running(update, context)                return            elif self.waiting_for_group_id and str(update.effective_user.id) == self.config['admin_id']:                await self.handle_group_id(update, context)                return            # معالجة رمز العملة المباشر (مثل BTC, ETH)            if len(text.split()) == 1 and text.isalpha() and len(text) <= 10:                await self._get_price_and_reply(update, context, text)                return        except Exception as e:            error_msg = f"خطأ في معالجة النص: {e}"            logger.error(error_msg)            await self.send_to_error_group(error_msg)    async def clean_cache(self):        """تنظيف البيانات المؤقتة المنتهية الصلاحية"""        try:            current_time = time.time()            expired = [key for key, (_, timestamp) in self.cached_data.items()                       if current_time - timestamp > 3600]                        for key in expired:                del self.cached_data[key]            if expired:                event_logger.info(f"تم تنظيف {len(expired)} عنصر من الذاكرة المؤقتة")        except Exception as e:            logger.error(f"خطأ في تنظيف الذاكرة المؤقتة: {e}")    async def schedule_cache_cleanup(self):        """جدولة تنظيف الذاكرة المؤقتة كل ساعة"""        while True:            await self.clean_cache()            await asyncio.sleep(3600)async def error_handler(update: object, context):    """معالج الأخطاء العام"""    try:        logger.error(f"خطأ في التحديث {update}: {context.error}")                if isinstance(update, Update) and update.effective_message:            await update.effective_message.reply_text(                "⚠️ حدث خطأ غير متوقع. تم تسجيل المشكلة وسيتم إصلاحها قريباً."            )    except Exception as e:        logger.error(f"خطأ في معالج الأخطاء: {e}")async def main():    """الدالة الرئيسية لتشغيل البوت"""    application = None    bot = None        try:        # إعداد البوت        bot = TradingBot(CONFIG)        application = Application.builder().token(CONFIG['telegram_token']).build()        bot.application = application        # إضافة معالجات الأوامر        application.add_handler(CommandHandler("start", bot.start))        application.add_handler(CommandHandler("help", bot.help))        application.add_handler(CommandHandler("price", bot.price))        application.add_handler(CommandHandler("search", bot.search))        application.add_handler(CommandHandler("chart", bot.chart))        application.add_handler(CommandHandler("running", bot.running))        application.add_handler(CommandHandler("admin", bot.admin_panel))        application.add_handler(CallbackQueryHandler(bot.handle_admin_callback, pattern="^admin_"))        application.add_handler(CallbackQueryHandler(bot.handle_chart_callback, pattern="^chart_"))        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_text))        # إعداد معالجة الأخطاء        application.add_error_handler(error_handler)        # تشغيل البوت        logger.info("جاري تشغيل البوت...")        await bot.send_to_log_group("🚀 تم تشغيل البوت بنجاح!")        # تشغيل تنظيف الذاكرة المؤقتة في الخلفية        asyncio.create_task(bot.schedule_cache_cleanup())        # تشغيل البوت        await application.initialize()        await application.start()        # تشغيل البوت في وضع الاستماع        await application.updater.start_polling()        # انتظار الإشارة للإيقاف        try:            while True:                await asyncio.sleep(1)        except asyncio.CancelledError:            pass    except Exception as e:        error_msg = f"خطأ في تشغيل البوت: {e}\n{traceback.format_exc()}"        logger.error(error_msg)        if bot:            try:                await bot.send_to_error_group(error_msg)            except Exception as send_error:                logger.error(f"فشل في إرسال رسالة الخطأ: {send_error}")    finally:        if application:            try:                await application.updater.stop()                await application.stop()                await application.shutdown()            except Exception as shutdown_error:                logger.error(f"خطأ في إغلاق البوت: {shutdown_error}")def run_bot():    """تشغيل البوت مع معالجة الأخطاء"""    try:        # إعداد معالجة الأخطاء غير المتوقعة        sys.excepthook = lambda exc_type, exc_value, exc_traceback: logger.error(            f"خطأ غير متوقع: {exc_value}\n{''.join(traceback.format_tb(exc_traceback))}"        )        # تشغيل البوت        asyncio.run(main())    except KeyboardInterrupt:        logger.info("تم إيقاف البوت بواسطة المستخدم")    except Exception as e:        error_msg = f"خطأ في تشغيل البرنامج: {e}\n{traceback.format_exc()}"        logger.error(error_msg)        print(f"خطأ فادح: {error_msg}")if __name__ == '__main__':    run_bot()